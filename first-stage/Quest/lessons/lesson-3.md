# 3 Урок

## Содержание
- Создание обычного [NPC](#обычный-бот)
- Создание [NPC](#квестгивер), с которым можно будет взаимодействовать
- Поработают с оператором `match`
- [Допы](#допы)

## Обычный бот
### Подготовка сцены бота

Создадим новую сцену для NPC (Non-player character) не дающего заданий. 

Основным узлом будет `CharacterBody2D` и к нему мы присоединяем `AnimatedSprite2D` и `CollisionShape2D`. Анимации и коллизию делаем как у игрока полсе чего переходим к скрипту.

![image](https://github.com/user-attachments/assets/1db6af3f-d422-4a10-9051-468f05dc4254)

> Как можно заметить - у ботов похожий спрайт, следовательно, то же самое смещение

Для реализации нам понадобятится 4 переменные

```gdscript
var move_dir = Vector2.ZERO # переменная в которой храним направление бота
var move_speed = 50 # его скорость
var time_to_change_dir = 2 # время для смены направления движения (можете сделать его рандомным)
var timer = 0 # таймер, который будет доходить до значения time_to_change_dir, а затем сбрасываться
```

После чего в process прописываем случайное перемещение бота каждые 2 секунды

```gdscript
func _physics_process(delta): # метод, который вы должны использовать для всего, что предполагает использование физического движка
	timer += delta;
	if timer >= time_to_change_dir:
		timer = 0
		move_dir = Vector2(randf_range(-1, 1), randf_range(-1, 1)).normalized()
	
	set_velocity(move_dir * move_speed)
	move_and_slide()

func _process(delta): # а этот метод можно использовать для обработки анимаций и прочих операций, которые не обрабатывают физику
	if move_dir == Vector2(0,0): # если бот стоит на месте, то его анимация будет следующая:
		move_anim(move_dir) # имя метода ниже и в него записан аргумент, который передается в параметр метода move_anim()
	else: # иначе:
		move_anim(move_dir) # имя метода ниже и в него записан аргумент, который передается в параметр метода move_anim()
	
	

func move_anim(move_dir: Vector2): # метод внутри которого объявляется параметр с типом Vector2, который метод хочет получить и в него мы передаем значение направления бота
	if move_dir == Vector2.ZERO: # далее мы исходя из данных move_dir меняем анимацию бота
		$AnimatedSprite2D.play("idle")
	if move_dir.x > 0:
		$AnimatedSprite2D.flip_h = false
	else:
		$AnimatedSprite2D.flip_h = true
		
	if move_dir.y > 0:
		$AnimatedSprite2D.play("walk")
	else:
		$AnimatedSprite2D.play("walk_up")
```

>[!IMPORTANT]
>Параметры — это переменные, задаваемые при создании функции, которые служат для хранения данных, используемых внутри этой функции. Аргументы — это конкретные значения, передаваемые функции во время её вызова. Проще говоря, если рассматривать функцию как рецепт, то параметры представляют собой список ингредиентов, а аргументы — это те ингредиенты, которые вы добавляете в процессе приготовления. 

```gdscript
# это пример
func pie(apple: int):  # Здесь 'apple' — это параметр функции
    print("У вас есть ", apple, " яблок(а) для пирога.")

# Вызов функции с аргументом
pie(5)  # Здесь '5' — это аргумент, передаваемый функции
```

На уровне добавляем отдельный узел Node2D где будут хранится все NPC, после чего присоединяем туда наших ботов.
![image](https://github.com/user-attachments/assets/b1cc1e49-c488-454a-b1ab-fa5dad5720dc)

> Как видно, `Ordering`, а точнее свойство `Y Sort Enabled` - включен. Поэтому будет работать сортировка по Y у всех дочерних элементов 

## Говорящий NPC

Следующий подраздел начнем с создания персонажа, с которым игрок может взаимодействовать. Выглядеть он будет примерно так:

![image](https://github.com/user-attachments/assets/88aaa5d6-bfc4-424e-a2fe-fbc94a36231f)
>Заметь на скрине уже указан примерный параметр `offset`. Всё зависит от спрайта.

NPC которого мы сделаем будет стражник/робот или другой персонаж, который рассказывает что-то. От шуток до полезной информации игроку. Нам понадобятся следующие узлы:

* `Area2D`
* `AnimatedSprite2D`
* `CollisionShape2D` или `CollisionPolygon2D`

Разница между `CollisionShape2D` и `CollisionPolygon2D` заключается лишь в том, как ученик захочет сделать область взаимодействия с игроком. Более сложную или простую - зависит от учеников. Ну или ты сам можешь им дать
тот узел, который лучше подойдет по уровню. "Изикам" лучше дать `CollisionShape2D`.

Прикрепляем скрипт и добавляем сигналы от родительского узла к этому же скрипту.

![image](https://github.com/user-attachments/assets/c4b0a0c4-69e6-47f7-8428-4892f468bba0)

### Скрипт говорящего NPC

```gdscript
extends Area2D

# Пока пропишите pass, чтобы не было ошибок. К скрипту вы вернетесь позже
func _on_body_entered(body):
	if body.name == "Player":
		pass

func _on_body_exited(body):
	if body.name == "Player":
		pass
```


<details>

<summary>Можешь заранее посмотреть итоговый скрипт</summary>

 ```gdscript
extends Area2D


func _on_body_entered(body):
	if body.name == "Player":
		%TalkingBotInterface.visible = true 

func _on_body_exited(body):
	if body.name == "Player":
		%TalkingBotInterface.visible = false
```
</details>



Теперь нам нужно сздать сам диалог со NPC. Делать это мы будем в  `CanvasLayer`, который переименуем в `UI`. 

![image](https://github.com/user-attachments/assets/1a42705e-8521-42e4-98b0-52cbde959d5f)

>[!Note]
>Скрипт к `UI` пока прикреплять не надо. Вы можете это сделать заранее, но это не обязательно


Основным узлом будет `Control`. Переименуйте его в что-то вроде `TalkingBotInterface`, даете ему уникальное имя и присоединяйте следующие узлы:
* `Panel` 3 штуки
* `Label` 2 штуки. Один под имя и другой под текст
* `Button` 2 штуки или можете больше, если хотите
* Можете использовать `TextureRect` для хранения в нем картинок с персонажем

>[!WARNING]
>Выше написано про уникальное имя. Оно использует не <kbd>$</kbd> при обращении к узлу, а <kbd>%</kbd>. Сделано это для доступа к узлу по уникальному имени, т.е. можно обращаться к узлу, независимо от пути к этому узлу.

Делается это следующим образом:

![UniqueName](https://github.com/user-attachments/assets/29c851a7-7850-40cb-ba49-2ef9b44464f3)


Выглядеть это будет примерно так:

![image](https://github.com/user-attachments/assets/bd40c5e1-2c98-4955-b154-287a7c8efd41)
>Узлы

![image](https://github.com/user-attachments/assets/f5ae1c85-3fbb-4ba6-abdd-585ff7214e4b)
>Интерфейс

Расставляем интерфейс на свой вкус и цвет после чего приступаете к созданию скрипта.

>[!Important]
>Не забудьте указать у `Control` предустановку якорей на весь экран. ![image](https://github.com/user-attachments/assets/6faa1ddc-b35d-4fd2-805d-aa6175f83119)

После того, как расставили элементы интерфейса - создаем скрипт у `Control` после чего присоединяем сигналы от кнопок к этому скрипту.

### Скрипт интерфейса говорящего NPC

<details>
	<summary>Весь скрипт целиком</summary>

```gdscript
extends Control

func _on_option_1_pressed():
	$PanelOutside/PanelInside/Label.text = 'Таверна слева от вас.'


func _on_option_2_pressed():
	var answer = 0
	
	randomize()
	answer = randi_range(0, 5)
	match answer:
		0:
			$PanelOutside/PanelInside/Label.text = 'Шутка 1'
		1:
			$PanelOutside/PanelInside/Label.text = 'Шутка 2'
		2:
			$PanelOutside/PanelInside/Label.text = 'Шутка 3'
		3:
			$PanelOutside/PanelInside/Label.text = 'Шутка 4'
		4:
			$PanelOutside/PanelInside/Label.text = 'Шутка 5'

```

</details>

Присоедините хотя бы две кнопки. Первой кнопке пропишите достаточно простое действие - отображение текста. То есть нажатие на эту кнопку будет просто выводить текст на экране. 
А на самих кнопках можно сделать надписи что-то вроде: 
1) "Как пройти в таверну?" - на первой кнопке
2) "Расскажи шутку" - на второй кнопке

```gdscript
extends Control

func _on_option_1_pressed():
	$PanelOutside/PanelInside/Label.text = 'Тут пропишите свой текст'
```

А вот со второй кнопкой будет интереснее. 

>[!Tip]
>Ты можешь спросить у детей: `"Как сделать так, чтобы бот всегда отвечал по-разному на один и тот же вопрос?"`
>Кто-то должен догадаться про рандом, но если нет - ты подталкиваешь их в ответу.



```gdscript
extends Control

func _on_option_2_pressed():
	var answer = 0; # создаем переменную, которая будет хранить в себе номер ответа
	randomize() # эта функция генерит каждый раз новый сид (seed), чтобы обеспечить более-менее настоящий рандом
	answer = randi_range(0, 5) # тут можешь указать свой диапазон диалогов
	match answer:
		0:
			$PanelOutside/PanelInside/Label.text = 'Шутка 1'
		1:
			$PanelOutside/PanelInside/Label.text = 'Шутка 2'
		2:
			$PanelOutside/PanelInside/Label.text = 'Шутка 3'
		3:
			$PanelOutside/PanelInside/Label.text = 'Шутка 4'
		4:
			$PanelOutside/PanelInside/Label.text = 'Шутка 5'
```

Давай теперь подробнее: 

1. `var answer = 0`: Эта строка создает переменную `answer` и присваивает ей начальное значение `0`. Переменные используются для хранения данных, которые мы можем изменять в процессе выполнения программы.

2. [`randomize()`](https://docs.godotengine.org/en/4.3/classes/class_@globalscope.html#class-globalscope-method-randomize): Эта функция используется для инициализации генератора случайных чисел. Она помогает сделать так, чтобы каждый раз, когда мы вызываем её, случайные числа были разными.

3. `answer = randi_range(0, 5)`: Здесь мы вызываем функцию `randi_range(0, 5)`, которая генерирует случайное целое число в диапазоне от 0 до 5 (включительно). Сгенерированное число сохраняется в переменной `answer`. Это значит, что теперь `answer` может принимать значения 0, 1, 2, 3, 4 или 5.

4. [`match`](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#match)`answer:`: Это конструкция, которая позволяет проверить значение переменной `answer` и выполнить соответствующий блок кода в зависимости от его значения. Это похоже на оператор `switch` в других языках программирования.

5. Далее идут блоки кода, которые начинаются с 0:, 1:, 2:, и так далее. Каждый из этих блоков соответствует одному из возможных значений `answer`. Например:

   • Если `answer` равно 0, то выполняется код `$PanelOutside/PanelInside/Label.text = 'Шутка 1'`. Это означает, что текст элемента интерфейса (`Label`) будет изменен на `'Шутка 1'`.

   • Если `answer` равно 1, то текст станет `'Шутка 2'`, и так далее для значений от 0 до 4.

В общем: этот код генерирует случайное число и в зависимости от этого числа показывает одну из пяти шуток на экране.

>[!Tip]
>Если ученик задаст вопрос про разницу `match` и `if` можешь сказать им, что разница заключается в области применения этих операторов.
>Они быстрее, чем операторы `if`, но если ваш оператор `if` невелик, то нет смысла переходить на оператор `match`.

Основные различия `match` и `if`:

1. Тип проверки:
   - `if` проверяет условия, которые могут быть логическими выражениями.
   - `match` проверяет значение на соответствие конкретным паттернам.
2. Читаемость:
   - `match` может быть более читаемым и компактным при работе с множеством значений, особенно если есть множество вариантов для одного значения.
3. Гибкость:
   - `if` более гибок для сложных условий, где может потребоваться логическая комбинация (например, and, or).

### Добавление на сцену

![image](https://github.com/user-attachments/assets/64375633-f550-47b2-b736-56a9a1d57753)

Теперь дело за малым. Добавляете NPC в узел `Bots` и ставите где-нибудь на карте.

![image](https://github.com/user-attachments/assets/8a613b89-a3a2-46b4-b8cb-3e114240add2)

И прописываете финальный штрих в скрипте говорящего бота:

```gdscript
extends Area2D
# это тот скрипт бота


func _on_body_entered(body):
	if body.name == "Player":
		%TalkingBotInterface.visible = true # pass'ы меняешь на переключение видимости

func _on_body_exited(body):
	if body.name == "Player":
		%TalkingBotInterface.visible = false
```

# Итоги
- Ученики изучили добавление уникального имени. В будущем это сильно облегчит им работу.
- Написали двух ботов.
- Изучили оператор `match`. Достаточно важный оператор в разработке. Может расширить вариативность и гибкость кода.
