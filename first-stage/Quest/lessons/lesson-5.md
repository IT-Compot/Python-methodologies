# 5 Урок

## Программируем интерфейс
## Общий интерфейс 
Для удобства создадим скрипт внутри `CanvasLayer` и переименуем его в `UI`, если это не было сделано ранее. Также задайте ему уникальное имя.
Хранить квесты, для относительной простоты, мы будем внутри данного узла.

![image](https://github.com/user-attachments/assets/78f162c0-c7d2-4250-839c-7f0a7c22f965)

Все, что нужно добавить в скрипт это:

```gdscript
extends CanvasLayer


var quest = [] # массив с квестами

```

>[!WARNING]
>Тут надо внести ясность: списки и массивы работают по-разному в GDScript и Python.
>
>Так в Python: Список = динамическая коллекция; массив = ограниченная коллекция одного типа
>
>GDScript: Массив = список (одинаковая функция).

#### Внесем еще больше ясности, для общего развития

##### GDScript

- Массив: Это структура данных, которая может хранить упорядоченные элементы. В GDScript массивы динамические, и их размер может изменяться. Элементы могут быть разных типов (числа, строки и т.д.).

- Список: В GDScript нет отдельного типа "список". Массивы выполняют ту же функцию, что и списки в других языках.

##### Python

- Список: Это встроенный тип данных, который также хранит упорядоченные элементы. Списки динамические, могут содержать элементы разных типов и поддерживают множество методов для манипуляций (добавление, удаление, сортировка).

- Массив: В Python обычно используется модуль array, который предоставляет более ограниченные возможности по сравнению со списками. Массивы требуют, чтобы все элементы были одного типа, и чаще используются для работы с числовыми данными.


> Говорить можешь так: "Сперва нам нужно создать переменную, которая будет хранить в себе квесты. Тип данных у этой переменной - массив. Список позволит нам хранить множество значений, но мы будем использовать текстовый.

## Интерфейс со списком квестов

Так как квестов у нас может быть несколько нам нужно будет выводить их циклом. 

>[!Tip]
>Спроси у учеников как можно постоянно выводить несколько объектов на экран? Какой оператор хорошо подойдет для этой задачи? И если угадают с оператором, то в каком методе лучше выводить? В `process(delta)` или в `physics_process(delta)`? А может вообще в `ready()`?

Сперва покажу все узлы, которые будут тут лежать.

![image](https://github.com/user-attachments/assets/9f6f5dbf-0d16-4854-a0e2-96d5a45bd7f5)

`QuestList` - это узел `Control`, который нужно расстянуть по всему [`viewport`](https://docs.godotengine.org/en/stable/classes/class_viewport.html). Делается это следующим образом:

![image](https://github.com/user-attachments/assets/bdd19202-9831-4038-90d5-1ef39f2f49c5)

1) Выбираешь узел `Control`
2) Жмешь на кнопку предустановки якорей ![image](https://github.com/user-attachments/assets/9e2ed829-614b-4e80-926c-48cec39adbe6)
3) Выбираешь `Полный прямоугольник` ![image](https://github.com/user-attachments/assets/b227ecf3-5eb9-4784-bf2e-0b306a13993d)

Отлично! Теперь надо добавить узлы для верстки экрана. Разберем `MarginContainer` и `VBoxContainer`.


`MarginContainer` — это контейнер, который позволяет задавать отступы (margin) вокруг своих дочерних узлов. Это полезно, когда нужно создать пространство между краем контейнера и его содержимым.

![image](https://github.com/user-attachments/assets/a1cc27fd-76fa-4f23-976a-86e0cc4a1c5b)

Вы можете задать необходимые отступы с любой стороны.

`VBoxContainer` — это контейнер, который располагает своих дочерних узлов вертикально в столбик. Он автоматически управляет размером и положением дочерних узлов, чтобы они располагались друг под другом.

```plaintext
VBoxContainer
├── Button (Текст: "Начать игру")
├── Button (Текст: "Настройки")
└── Button (Текст: "Выход")
```
- Вы можете настроить отступы между элементами внутри `VBoxContainer`, установив свойства `Separation` в инспекторе.
- Например, если вы установите `Separation` на 10, то между каждой кнопкой будет расстояние в 10 пикселей.

Как же нам их использовать вместе? Всё просто.
1. Создайте `MarginContainer`.
2. Внутри него добавьте `VBoxContainer`.
3. Внутри VBoxContainer добавьте ваши элементы (в нашем случае - `Label`).

```plaintext
MarginContainer
└── VBoxContainer
    ├── Label (Текст: "Квест 1")
    ├── Label (Текст: "Квест 2")
    └── Label (Текст: "Квест 3")
```
И вот так просто мы сможем добавлять лейблы в наш список квестов и они автоматически будут сортироваться вниз с заданными отступами и разделением.

>[!CAUTION]
>Однако вариант c добавлением новых узлов применим только для ультра-хардов (в разработке версия для хардов).
>Всем остальным рекомендуется делать, как будет показано ниже, через переписывание текущего Label. Но мы все равно сделали небольшую верстку. Этот опыт может понадобиться ученикам во время созданий меню.


### Скрипт списка квестов

```gdscript
@onready var quest_name = %QuestName # ссылка на дочерний Label 

func _process(delta):
	var quest_list = "Список заданий:\n" # переменная с текстом из лейбла
	for quest in %UI.quest: # отображаем количество квестов
		quest_list += quest + "\n" # дописываем имя квеста и добавляем перенос строки
		quest_name.text = quest_list # переписываем текст
```

## Интерфейс квестгивера

Далее мы добавляем узел интерфейса (`Control`), переименовали его в `QuestGiverInterface` или что-то похожее и задали ему уникальное имя. После - прикрепляем скрипт.
В этом узле мы будем обрабатывать логику выдачи квеста и работу с ним в принципе.

Полные скрипты для ознакомления представлены ниже.

Начать можете с чего-то подобного:

```gdscript
@onready var ui = %UI # ссылка на узел, где мы будем хранить квесты
signal quest_accepted # нужен будет для передачи сигнала в узел с предметами, чтобы там произошел спавн объектов

func _process(delta): 
	if ui.quest.has("Собери склянку"): # если в списке есть такой квест, то будет следующее
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # можете переименовать Label и задать ему уникальное имя, чтобы сократить обращение к узлу
		Ты бы знал, как сильно выручил меня!"

func _on_option_1_pressed(): # прикрепляете сигнал от кнопки
	if ui.quest.is_empty() or !ui.quest.has("Собери склянку") and !ui.quest.has("Отнеси обратно склянку"): # если в квесте пусто или там нет принимаемых квестов
		ui.quest.append("Собери склянку") # принимаем его и добавляем в quest
		


func _on_option_2_pressed(): # если отказываемся, то просто выключаем область для нас
	%QuestGiver.in_area = false # не забывайте про уникальные имена узлов, чтобы путь к ним был значительно короче
```

А прийти к этому:

>[!Warning]
>Ваш код не обязательно должен быть, как код ниже. Это лишь возможный вариант, к которому можно прийти. В этом коде представлены возможные диалоги и ветвления.

```gdscript
extends Control

signal quest_accepted
@onready var ui = %UI

func _process(delta): # вы прописываете здесь все необходимые ветвления и условия для вашего квеста. Более-менее универсальный вариант представлен здесь
	if ui.quest.has("Собери склянку"): # проверяете есть ли в массиве такой элемент
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # в случае успеха проверки условия будет выполняться данный код
		Ты бы знал, как сильно выручил меня!" # текст можно переносить на разные строки
	if ui.quest.has("Отнеси обратно склянку"):
		$PanelOutside/PanelInside/Label.text = "Спасибо огромное! 
		Теперь я не погибну от рук берсерка."
		$Option_1.text = "Вот, держи свой эстус"
		$Option_2.text = "Хотя... Он мой"
	if ui.quest.has("Задание от Кассандры: Выполнено"):
		$PanelOutside/PanelInside/Label.text = "Теперь меня никто
		не остановит!"
	if ui.quest.has("Задание от Кассандры: Вы плохой человек"):
		$PanelOutside/PanelInside/Label.text = "Уходи. Глаза бы мои
		тебя не видели. Так ведь нельзя."
		$Option_1.text = "Понял. Ухожу"
		$Option_2.text = "Бывает такое"


func _on_option_1_pressed():
	if ui.quest.is_empty() or !ui.quest.has("Собери склянку") and !ui.quest.has("Отнеси обратно склянку"):
		ui.quest.append("Собери склянку")
		emit_signal("quest_accepted")
	if ui.quest.has("Отнеси обратно склянку"):
		ui.quest.erase("Отнеси обратно склянку")
		ui.quest.append("Задание от Кассандры: Выполнено")


func _on_option_2_pressed():
	if ui.quest.has("Отнеси обратно склянку"):
		ui.quest.erase("Отнеси обратно склянку")
		ui.quest.append("Задание от Кассандры: Вы плохой человек")
	%QuestGiver.in_area = false

```
>[!Tip]
>Внимательно почитай код, чтобы понять что и зачем нужно. На самом деле всё не так сложно

Начнем с простого:
```gdscript
@onready var ui = %UI # возможно так будет проще, чем каждый раз ставить знак процента

```

После этого присоединяете сигналы от кнопок, сразу оба. И пишете следующий код:

```gdscript
func _on_option_1_pressed():
	if ui.quest.is_empty() or !ui.quest.has("Тут пишете имя квеста, который не должен сейчас мешаться"):
		ui.quest.append("Тут пишете имя квеста")
		


func _on_option_2_pressed():
	%QuestGiver.in_area = false
```
>Можешь сказать: "Логика такая, ребята: на кнопку с принятием квеста мы проверяем пусто ли в массиве с квестами и нет ли там нашего квеста.
>
>Если нет, то добавляем его в массив и в дальнейшем сможем с ним работать."

Как добавили кнопки и квест - можете приступать к проверке наличия квеста в массиве.
Код:
```gdscript
func _process(delta):
	if ui.quest.has("Тут пишете имя квеста"):
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # просто для примера, можете свое придумать, можете взять
		Ты бы знал, как сильно выручил меня!"
```
<details>
	<summary>Небольшая памятка по методам массивов</summary>
	
#### Методы для работы с массивами

1. `append(value)`

Добавляет элемент в конец массива.

```gdscript
var my_array = []
my_array.append(5)  # Теперь my_array = [5]
my_array.append(10) # Теперь my_array = [5, 10]
```

2. `remove(index)`

Удаляет элемент по указанному индексу.
```gdscript
var my_array = [5, 10, 15]
my_array.remove(1)  # Удаляет элемент с индексом 1 (10)
# Теперь my_array = [5, 15]
```

3. `erase(value)`

Удаляет первое вхождение указанного значения из массива.
```gdscript
var my_array = [5, 10, 15, 10]
my_array.erase(10)  # Удаляет первое вхождение 10
# Теперь my_array = [5, 15, 10]
```

4. `has(value)`

Проверяет, содержится ли значение в массиве. Возвращает true или false.
```gdscript
var my_array = [5, 10, 15]
print(my_array.has(10))  # Вывод: true
print(my_array.has(20))  # Вывод: false
```

5. `clear()`

Очищает массив, удаляя все элементы.
```gdscript
var my_array = [5, 10, 15]
my_array.clear()  # Теперь my_array = []
```

6. `size()`

Возвращает количество элементов в массиве.
```gdscript
var my_array = [5, 10, 15]
print(my_array.size())  # Вывод: 3
```

7. `insert(index, value)`

Вставляет элемент по указанному индексу.

```gdscript
var my_array = [5, 10, 15]
my_array.insert(1, 7)  # Вставляет 7 на позицию с индексом 1
# Теперь my_array = [5, 7, 10, 15]
```

8. `sort()`

Сортирует массив (по возрастанию).
```gdscript
var my_array = [15, 5, 10]
my_array.sort()  # Теперь my_array = [5, 10, 15]
```
</details>

## Создание предмета для квеста

![image](https://github.com/user-attachments/assets/764a76e6-dec3-498c-a976-8036368d147f)

> Это может быть любой другой предмет. Зависит от истории ученика.

Из чего состоит подбираемый предмет:
![image](https://github.com/user-attachments/assets/fe740b3e-772c-4234-83ae-1f79e4b8575d)

Скрипт достаточно простой:

```gdscript
func _on_body_entered(body): # сигнал, который исходит от самого узла
	if body.name == "Player": # проверка имени игрока
		body.item_collected() # вызов метода у тела
		queue_free() # удаление предмета
```
Сигнал `body_entered` прикрепляете к самому скрипту предмета.

Метод `item_collected()` вызывается у `body`, а этот самый `body` в нашем случае - Игрок. Поэтому в скрипте игрока создаете метод `item_collected()` и прописываете следующее:

```gdscript
# player.gd
func item_collected():
	%UI.quest.append("Имя добавляемого квеста")
	%UI.quest.erase("Имя стираемого квеста")
```

### Создание узла для предметов

Создайте новый Node2D и переименуйте его, чтобы помещать туда в дальнейшем объекты, которые мы будем спавнить из скрипта

![image](https://github.com/user-attachments/assets/6edec8ca-5bdc-41f5-87ca-7c2dcc76257e)

И сразу крепите к нему скрипт

```gdscript
# как обычно - сперва полный скрипт, чтобы было понимание того, что мы делаем
# а дальше по порядку

@export var glass_scene : PackedScene # сюда мы положим сцену
@export var min_glass = 1 # эти переменные опциональны, на случай, если вы будете с хардами делать генерацию нескольких предметов
@export var max_glass = 5 # 


func _on_quest_giver_window_quest_accepted(): # сигнал, который приходит от интерфейса квеста
	spawn_item() # вызов метода, который будет спавнить предметы

# вариант 1 
func spawn_item(): # вы можете создать такой метод
	var glass = glass_scene.instantiate() # инстанцируем сцену предмета
	glass.position = Vector2(randf_range(100, 100),randf_range(100, 100)) # задаем случайную позицию. Можно задать спавн в случайной точке или просто создать спавн в каком-то конкретном месте
	add_child(glass)
```

Можете попробовать вариант с конкретной точкой (так будет меньше багов)
```gdscript

# вариант 2
func spawn_item(): # или такой метод
	var glass = glass_scene.instantiate() # инстанцируем сцену предмета
	glass.position = $GlassSpawnPoint.position # можете задать спавн в конкретной точке
	add_child(glass)
```

Задаете конкретную позицию узлу Marker2D и переименовываете его.

![image](https://github.com/user-attachments/assets/1885b066-e4b3-419f-9d79-2c68deaf019c)

Остается только проверить подбор предмета. 
