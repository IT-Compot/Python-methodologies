# Урок 6 

# Время

![tick-tock-tick-tock-clock](https://github.com/user-attachments/assets/eb2e5fe4-5c4c-48df-ac90-98faa75320ff)


На этом уроке реализуем смену времени суток. Работать будем с [CanvasModulate](https://docs.godotengine.org/en/stable/classes/class_canvasmodulate.html)

Начнем с добавления узла. Его место в иерархии достаточно простое - просто крепите к родительскому узлу.

![image](https://github.com/user-attachments/assets/862b9006-d294-42d0-9a25-58a2ea40aaf1)

Добавляете уникальное имя и скрипт.

Чтобы поменять освещение на всей карте используйте свойство `Color` у `CanvasModulate`. Но работать с цветом мы будем, когда дойдем до прописывания смены суток.

![CanvasModulate_1](https://github.com/user-attachments/assets/f230c172-90dd-4032-9ce6-eddccb849ea9)

## Скрипт времени

<details>
  <summary>Полный скрипт</summary>

  ```gdscript
extends CanvasModulate

# Переменные для времени
var hours = 6.0  # Начальное время: 6 утра
var minutes = 0.0
var time_speed = 100  # Ускорение времени, сколько реальных секунд длится 1 игровая минута

# Переменные для освещения
@onready var canvas_modulate = $"."

func _process(delta):
	update_time(delta)
	update_lighting()

# Функция обновления времени
func update_time(delta):
	minutes += delta * time_speed  # Увеличиваем минуты с учётом скорости времени
	if minutes >= 60.0:
		minutes = 0.0
		hours += 1.0
	if hours >= 24.0:
		hours = 0.0

# Функция обновления освещения в зависимости от времени суток
func update_lighting():
	var total_time = hours + (minutes / 60.0)  # Учитываем часы и минуты для более точного времени

	if total_time >= 6.0 and total_time < 18.0:  # Дневное время
		canvas_modulate.color = lerp(Color(1, 1, 1), Color(0.781, 0.646, 0.54), float(total_time - 6.0) / 12.0)
	else:  # Ночное время
		if total_time >= 18.0:  # Вечернее время
			canvas_modulate.color = lerp(Color(0.781, 0.646, 0.54), Color(0.115, 0.106, 0.306), float(total_time - 18.0) / 6.0)
		elif total_time < 6.0:  # Глубокая ночь
			canvas_modulate.color = lerp(Color(0.115, 0.106, 0.306), Color(1, 1, 1), float(total_time) / 6.0)


  ```
</details>

>[!Tip]
>Смотри, как добавить тип `Color()` в скрипт: ![CanvasModulateColor](https://github.com/user-attachments/assets/49a32ddd-844a-434b-9730-fdc29eec6017)
>А затем эти данные вставляешь в скрипт.

### Давай разберем скрипт подробнее 

#### Функция `_process(delta)`
Эта функция вызывается каждый кадр игры и выполняет обновление времени и освещения. `delta` — это время, прошедшее с момента предыдущего кадра, что позволяет вычислять, насколько увеличилось игровое время.

#### Функция `update_time(delta)`
Эта функция отвечает за изменение времени. Она работает следующим образом:

Добавляет к минутам значение, которое зависит от `delta` (время между кадрами) и скорости изменения времени (`time_speed`). Таким образом, время увеличивается постепенно.
Если количество минут превышает 60, оно сбрасывается на 0, а к часам добавляется 1.
Если часы доходят до 24, они тоже сбрасываются на 0, так как в сутках 24 часа.
3. Функция `update_lighting()`
Эта функция управляет изменением освещения в зависимости от текущего времени.

Переменная `total_time` хранит текущее время суток, объединяя часы и минуты в одно дробное значение. Например, если сейчас 6 часов 30 минут, `total_time` будет равно 6.5.

Если время находится между 6 утра и 6 вечера (то есть от 6 до 18 часов), считается, что это дневное время, и цвет освещения меняется от яркого белого (в начале дня) до более тёплого, золотистого оттенка (ближе к вечеру).

Если время позже 18 часов, то это вечер и ночь. Освещение становится темнее: вечером оно переходит от золотистого к тёмному синему. В промежутке между полуночью и 6 часами утра цвет освещения снова светлеет, готовясь к рассвету.

Как работает изменение цвета:
Функция `lerp()` используется для плавного перехода между двумя цветами. Например, в дневное время, начиная с 6 часов утра, свет будет постепенно меняться с белого на тёплый тон к 18 часам вечера. Этот процесс зависит от дробного значения total_time, которое позволяет сделать переходы плавными.

>[!Note]
>Этот скрипт обеспечивает плавную смену времени и освещения, благодаря чему игрок не заметит резких переходов от дня к ночи или обратно. Это создаёт более естественное ощущение смены времени в игре.

#### А теперь давай по порядку

Добавляем основные переменные:

```gdscript
# Переменные для времени
var hours = 6.0  # Начальное время: 6 утра
var minutes = 0.0
var time_speed = 100  # Ускорение времени, сколько реальных секунд длится 1 игровая минута
```

>[!Tip]
>Можешь попробовать подловить учеников на вопросе с типом данных. "Почему мы используем число с плавающей точкой (`float`)?"
>Ответ: "Так будет работать плавная смена времени суток. Если бы был тип данных `int` смена происходила бы резко, а с `float` - более плавно.

Если будет удобно, то можете добавить сам `CanvasModulate` в скрипт

```gdscript
@onready var canvas_modulate = $"."
```

Создаете `_process(delta)` и оставляете там `pass`, чтобы не было ошибки.

```gdscript
func _process(delta):
  pass
```

### Метод обновления времени

>[!Important]
>Объясни детям, как работают часы, если вдруг у кого-то с этим проблемы или напомни (лишним не будет) и после этого позволь им самим написать скрипт.

Вот, что должно выйти:

```gdscript
func update_time(delta): # объявите функцию вместе, а дальше пусть пробуют сами
	minutes += delta * time_speed  # Увеличиваем минуты с учётом скорости времени. Этот момент тоже лучше подсказать им
	if minutes >= 60.0:
		minutes = 0.0
		hours += 1.0
	if hours >= 24.0:
		hours = 0.0
```

>Направляем детей на правильную мысль. Вообще должны справиться с этим. Можете при необходимости даже разобрать логику работы часов и потом позволить им самим написать скрипт.

### Метод обновления освещения

>[!Important]
>Вот тут точно лучше делать вместе, но харды могут попробовать поработать и сами. Главное показать им, как подставлять данные в функцию `lerp()`.

Рассказываем почему надо разделять время и освещение на две функции. Так как логика работы у них немного разная - лучше разделить.
>Так меньше ошибок будет возникать, а еще проще писать и читать код.


Начинаем с объявления метода:

```gdscript
func update_lighting():
	var total_time = hours + (minutes / 60.0)  # Учитываем часы и минуты для более точного времени
```
Этот блок кода отвечает за изменение освещения в игре в зависимости от времени суток, и он работает с переменной `total_time`, которая представляет текущее время в дробных значениях.
А вот дальше стоит немного напрячься. 

### Первая проверка

```gdscript
	if total_time >= 6.0 and total_time < 18.0:  # Дневное время
```

Здесь происходит проверка, какое сейчас время суток:
- `total_time >= 6.0` проверяет, что время больше или равно 6 утра. То есть это начало дня.
- `total_time < 18.0` проверяет, что время меньше 18 часов, или 6 вечера. Это конец дня.

Если оба условия выполнены, значит, текущее время находится в диапазоне между 6 утра и 6 вечера — это дневное время.

Дальше:

```gdscript
		canvas_modulate.color = lerp(Color(1, 1, 1), Color(0.781, 0.646, 0.54), float(total_time - 6.0) / 12.0)
```

Здесь происходит постепенное изменение освещения в течение дня, и для этого используется функция lerp(). Давайте разберём её подробнее:

1) `lerp(Color(1, 1, 1), Color(0.781, 0.646, 0.54), ...)`:
- `Color(1, 1, 1)` — это белый цвет, который символизирует яркое дневное освещение.
- `Color(0.781, 0.646, 0.54`) — это цвет с более тёплыми тонами, который используется для освещения ближе к вечеру. Например, это может быть золотистое освещение, как во время заката.
- Функция `lerp()` плавно изменяет цвет от белого к золотистому в течение дня.

2) `float(total_time - 6.0) / 12.0`:
- `total_time - 6.0` — это сколько часов прошло с начала дня (с 6 утра).
- `/ 12.0` — мы делим это число на 12, потому что дневное время длится 12 часов (с 6 утра до 6 вечера). Получается, что это дробная доля времени дня, которая говорит, насколько близко мы к вечеру. Например:
- В 6 утра (`total_time = 6.0`), результат будет 0, и освещение будет белым.
- В полдень (`total_time = 12.0`), результат будет 0.5, и освещение будет наполовину между белым и золотистым.
- В 6 вечера (`total_time = 18.0`), результат будет 1.0, и освещение станет полностью золотистым.

### Вторая проверка:

```gdscript
	else:  # Ночное время
    	if total_time >= 18.0:  # Вечернее время

```

Здесь мы проверяем, наступил ли вечер. Если текущее время больше или равно 18.0 (то есть 6 вечера и позднее), это означает, что день закончился, и наступает вечер.

```gdscript
			canvas_modulate.color = lerp(Color(0.781, 0.646, 0.54), Color(0.115, 0.106, 0.306), float(total_time - 18.0) / 6.0)
```

Теперь мы постепенно изменяем освещение с вечернего на ночное:

1) `lerp(Color(0.781, 0.646, 0.54), Color(0.115, 0.106, 0.306), ...)`:
- `Color(0.781, 0.646, 0.54)` — это тот же тёплый золотистый цвет, который был ближе к вечеру.
- `Color(0.115, 0.106, 0.306)` — это темный цвет, который используется для ночного освещения. Он имеет тёмно-синий оттенок, подходящий для ночного времени.
- Функция `lerp()` постепенно изменяет освещение с вечернего (тёплого) на ночное (тёмное).

2) `float(total_time - 18.0) / 6.0`:
- `total_time - 18.0` — это сколько часов прошло с начала вечера (с 6 вечера).
- `/ 6.0` — мы делим это число на 6, потому что вечернее время длится 6 часов (с 6 вечера до полуночи). Например:
- В 6 вечера (`total_time = 18.0`), результат будет 0, и освещение будет золотистым.
- В 9 вечера (`total_time = 21.0`), результат будет 0.5, и освещение будет на полпути между тёплым и тёмным.
- В полночь (`total_time = 24.0`), результат будет 1.0, и освещение станет полностью тёмным.

### Последняя проверка:

```gdscript
		elif total_time < 6.0:  # Глубокая ночь
```

Здесь проверяется, что текущее время меньше 6 утра, то есть сейчас глубокая ночь. Это время между полуночью и рассветом.

```gdscript
			canvas_modulate.color = lerp(Color(0.115, 0.106, 0.306), Color(1, 1, 1), float(total_time) / 6.0)
```
Здесь мы изменяем освещение с ночного на утреннее:

1) `lerp(Color(0.115, 0.106, 0.306), Color(1, 1, 1), ...)`:
- `Color(0.115, 0.106, 0.306)` — это тёмный ночной цвет.
- `Color(1, 1, 1)` — это белый цвет, который используется для освещения на рассвете.
- Функция `lerp()` плавно изменяет цвет от ночного (тёмного) к утреннему (яркому белому).

2) `float(total_time) / 6.0`:
- `total_time` — это текущее время, если оно меньше 6 (то есть между полуночью и рассветом).
- `/ 6.0` — делим это время на 6, так как ночное время длится от 0 до 6 утра. Например:
- В полночь (`total_time = 0.0`), результат будет 0, и освещение останется тёмным.
- В 3 часа ночи (`total_time = 3.0`), результат будет 0.5, и освещение начнёт светлеть.
- В 6 утра (`total_time = 6.0`), результат будет 1.0, и освещение станет белым, как при рассвете.

Отлично! Теперь у вас работает смена времени, но было бы неплохо еще это самое время отслеживать.

## Интерфейс отслеживания времени
Выглядеть это дело будет примерно так:

![image](https://github.com/user-attachments/assets/f8d155c2-7e89-48e4-bdfb-8900feab149d)

### Узлы

Добавляем узел `Control` к `UI` и переименовываем его в что-то вроде `TimeControl`, `TimeInterface` или можете придумать свое название.
Расположить можете где угодно в принципе, но рекомендуется поставить в правый верхний угол, как на картинке: 

![image](https://github.com/user-attachments/assets/140300cf-6935-44f3-826d-bcdb4f71ac69)

Узловая иерархия выглядит следующим образом: 

![image](https://github.com/user-attachments/assets/db198709-2bb9-4945-8701-5f04a3e8f0cf)

### Скрипт

<details>
	<summary>Полный скрипт</summary>
	
```gdscript
extends Control


func _process(delta):
	if %CanvasModulate.minutes < 10: # если минуты (по желанию можете добавить часы) меньше 10, то
		$MarginContainer/Label.text = str(int(%CanvasModulate.hours), ":0", int(%CanvasModulate.minutes)) # добавляем 0
	else: # иначе 0 не добавляется
		$MarginContainer/Label.text = str(int(%CanvasModulate.hours), ":", int(%CanvasModulate.minutes))

```

### Что делает этот скрипт?
Этот скрипт обновляет текст на экране в зависимости от времени. Время состоит из часов и минут, и оно отображается на экране в формате, который мы привыкли видеть: например, 8:05 (с нулём перед минутами, если их меньше 10) или 12:30.

### Основные элементы
`_process(delta)` — это функция, которая выполняется каждый кадр игры. Здесь `delta` — это время, прошедшее с момента последнего кадра. Но в данном скрипте мы `delta` не используем, а просто обновляем текст каждую секунду.

`%CanvasModulate.hours` и `%CanvasModulate.minutes` — это значения текущих часов и минут, которые хранятся в другом объекте. Мы их используем, чтобы показать время на экране.

### Логика скрипта

#### Первая проверка:
```gdscript
	if %CanvasModulate.minutes < 10:
```

Здесь скрипт проверяет, меньше ли минут 10. Почему это важно? Когда минут меньше 10, принято записывать их с нулём перед числом. Например:

- 8:05 вместо 8:5.

Если минут меньше 10, мы добавим этот ноль.

#### Обновление текста:

```gdscript
		$MarginContainer/Label.text = str(int(%CanvasModulate.hours), ":0", int(%CanvasModulate.minutes))

```
- `$MarginContainer/Label.text` — это текст на экране, который находится в элементе `Label`.
- `str(int(%CanvasModulate.hours), ":0", int(%CanvasModulate.minutes))` — здесь мы создаём строку, которая выглядит как часы и минуты:
- `int(%CanvasModulate.hours)` — это число часов.
- `":0"` — это строка, которая добавляет ноль перед минутами (если их меньше 10).
- `int(%CanvasModulate.minutes)` — это число минут.

#### Вторая часть:
Если минут 10 или больше:

```gdscript
else:
	$MarginContainer/Label.text = str(int(%CanvasModulate.hours), ":", int(%CanvasModulate.minutes))

```

Здесь всё аналогично, за исключением того, что ноль перед минутами не добавляется, так как минут уже 10 или больше. Например:

- 8:15
- 14:30

#### Объяснение для детей:
- Смысл этого кода в том, чтобы показывать часы и минуты на экране правильно: с нулём перед минутами, если их меньше 10.
- Когда минут меньше 10, мы добавляем ноль, чтобы получилось, например, "8:05" вместо "8:5".
- Когда минут больше 10, текст просто показывает их без изменений, например, "8:15".

</details>

### Начинаем создание скрипта

Здесь всё достаточно просто. Необходимо написать скрипт, который будет отслеживать актуальное значение переменных у `CanvasModulate`.

>Спросите у детей какой метод подойдет для этой задачи. `process(delta)` или `physics_process(delta)`?
>
>Ответ: `process(delta)`.

Объявляете необходимый метод и прописываете в нем следующее:

```gdscript
func _process(delta):
	$MarginContainer/Label.text = str(int(%CanvasModulate.hours), ":", int(%CanvasModulate.minutes)) # после того как напишете - проверьте интерфейс
```

- `$MarginContainer/Label.text` — это текст на экране, который находится в элементе `Label`.
- `str(int(%CanvasModulate.hours), ":0", int(%CanvasModulate.minutes))` — здесь мы создаём строку, которая выглядит как часы и минуты:
- `int(%CanvasModulate.hours)` — это число часов.
- `":0"` — это строка, которая добавляет ноль перед минутами (если их меньше 10).
- `int(%CanvasModulate.minutes)` — это число минут.

>[!Note]
>`str()` это функция для преобразования данных в `String` (строка)
>
>`int()` это функция для преобразования данных в `Integer` (целое число)

При запуске игры дети могут заметить, что время работает как-то не так. Формат времени у вас без дополнительного нуля для `чисел меньше десяти`. Подобной формулировкой вы можете подтолкнуть детей в нужное направление.

![TimeNotCorrect](https://github.com/user-attachments/assets/03da113d-259e-4d0b-b55a-01676c391f94)

Попробуйте дать им исправить этот момент самостоятельно.

Итоговый скрипт:

```gdscript
func _process(delta):
	if %CanvasModulate.minutes < 10:
		$MarginContainer/Label.text = str(int(%CanvasModulate.hours), ":0", int(%CanvasModulate.minutes))
	else:
		$MarginContainer/Label.text = str(int(%CanvasModulate.hours), ":", int(%CanvasModulate.minutes))
```

![TimeIsCorrect](https://github.com/user-attachments/assets/7a313eea-09b8-42fd-8d06-8f368c440c70)


И вот теперь у учеников исправленные часы. Вкусно и удобно.
