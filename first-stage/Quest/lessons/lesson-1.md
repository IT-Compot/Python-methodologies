# 1 Урок (Квест)

## Краткое содержание
- Создание изометрической [карты](#карта) разного уровня сложности. С несколькими слоями - для хардов, с одним - для медиум и изиков.
- Создание [игрока](#игрок) с разными механиками
- [Допы](#допы)


## Игрок

### Создание игрока (передвижение на клавиатуре)

Начнем с создания игрока. Выбирайте `Другой узел`, чтобы выбрать любой другой узел в качестве корневого в сцене.

![image](https://github.com/user-attachments/assets/0a82f863-95ae-4115-9cc7-811c60ebefef)


Основным узлом будет `CharacterBody2D` и к нему мы присоединяем `AnimatedSprite2D`, `Camera2D` и `CollisionShape2D`

![image](https://github.com/user-attachments/assets/9b40bb8f-306e-4990-b792-fd0104eeb1ac)

>[!Tip]
>На скрине представлены сразу же параметры камеры. Можете воспользоваться ими или же подобрать на свой вкус

#### Анимация

У спрайта создаем 3 анимации:
* Стоим и повернуты вниз
* Идем вверх
* Идем вниз

![AnimationsGif](https://github.com/user-attachments/assets/69ef6282-24bb-4bdc-b0ca-a2a40dfea59d)

Чтобы добавить кадр из спрайт-лист (это картинка с кучей кадров), нужно нажать на следующую кнопку:

![image](https://github.com/user-attachments/assets/55d6db3d-7495-47d0-ab71-55b018f4780a)

Находите нужный спрайт-лист и настраиваете количество линий и выбираете необходимые кадры:

![image](https://github.com/user-attachments/assets/ff4f2ce0-a57b-406b-a62c-bbf681c22c61)

>[!Note]
>Сколько и какие кадры вставлять в анимацию разберетесь по ходу работы или можно посмотреть на гифке выше

Так же необходимо выставить смещение (`offset`). 

![image](https://github.com/user-attachments/assets/c3be4147-6b3f-40e9-8fc7-14230ef8e00f)

>[!Tip]
>Можете сказать им, что это сыграет свою роль в будущем или же прямо сказать для чего это надо.

#### Коллизия

Коллизию задаем у нижней части игрока, так как игра изометрическая.

![image](https://github.com/user-attachments/assets/80a3d2c5-65c1-4ca5-9437-7d7bd28c2363)

#### Камера
Про камеру нужно поговорить чуть-чуть подробнее, если вы раньше особо не трогали её свойства.

- `Zoom` отвечает за приближение камеры к её центру
- `Position Smoothing` включает плавность камеры

#### Скрипт игрока
Прикрепи скрипт к корневому узлу CharacterBody2D, который следует переименовать в `Player`. Рекомендуй детям называть узлы осмысленно и с большой буквы, без пробелов. Вы используете [CamelCase](https://ru.wikipedia.org/wiki/CamelCase) в общем.
Переходим к скрипту, изначально создаем 2 переменные.

```gdscript
var motion = Vector2()
@export var speed = 200 # экспортируемая переменная, которая добавляется в инспектор узла к которому прикреплен скрипт.
```
![image](https://github.com/user-attachments/assets/3b5bbbfc-b334-4a87-a84c-3f106c47e7f6)

>Как видишь тут даже указан скрипт из которого пришло это свойство

>[!Tip]
>Сперва можешь задать лишь одно направление или максимум два. 

```gdscript
func _physics_process(delta):
	motion = Vector2() # мы изначально делаем motion равным нулю (допускается вариант Vector2.ZERO)
	if Input.is_action_pressed("up"): # нажимаем на W
		motion.y = -speed # уменьшаем Y с значением speed

  	set_velocity(speed) # Это нужно для того чтобы персонаж двигался и скорость не складывалась, если мы идем по диагонали
	move_and_slide() # Этот метод так же важен для перемещения игрока
```
Обязательно дайте возможность детям проявить себя и попробовать написать движение персонажа в другие стороны. Особенно можно похвалить тех, которые написали по-своему. Главнее, чтобы перемещение работало.

>Ссылки для подробного изучения работы методов [`set_velocity()`](https://docs.godotengine.org/en/4.3/classes/class_characterbody2d.html) и [`move_and_slide()`](https://docs.godotengine.org/en/4.3/classes/class_characterbody2d.html#class-characterbody2d-method-move-and-slide) 

И теперь задаем само передвижение + анимации
```gdscript
func _physics_process(delta):
	motion = Vector2() # мы изначально делаем motion равным нулю (допускается вариант Vector2.ZERO)
	if Input.is_action_pressed("up"): # нажимаем на W
		motion.y = -speed # уменьшаем Y с значением speed
		$AnimatedSprite2D.play("walk_up") # Анимация вверх
	if Input.is_action_pressed("right"): 
		motion.x = speed 
		$AnimatedSprite2D.flip_h = false # отключаем flip_h при движении вправо
		if $AnimatedSprite2D.animation == "idle_down": # это нужно, чтобы анимация не ломалась т.к. при движении вправо-влево ->
			$AnimatedSprite2D.play("walk_down") # ломается анимация и таким образом мы с анимации idle переключаемся на анимацию движения

	if Input.is_action_pressed("left"): # здесь вся та же история, но движение в другую сторону
		motion.x = -speed
		$AnimatedSprite2D.flip_h = true
		if $AnimatedSprite2D.animation == "idle_down":
			$AnimatedSprite2D.play("walk_down")

	if Input.is_action_pressed("down"):
		motion.y = speed
		$AnimatedSprite2D.play("walk_down")
	
	if motion == Vector2(): # если движение равно 0 по обоим векторам (можно Vector2.ZERO)
		$AnimatedSprite2D.play("idle_down") # то включается эта анимация

  	set_velocity(motion.normalized() * speed) # Это нужно для того чтобы скорость не складывалась если мы идем по диагонали
	move_and_slide()
```
>[!TIP]
>Хорошей практикой считается разделение обработчика анимаций и обработчика физики в разные методы. Анимации - в process(delta), а физику - в physics_process(delta). [Ссылка](https://docs.godotengine.org/en/stable/tutorials/scripting/idle_and_physics_processing.html) на официальную документацию. С хардами можно заморочиться и разделить управление и анимации на различные обработчики.

>Пример вопроса: Как вы думаете, почему стоит метод обработчика физики добавлять именно в `physics_process(delta)`?  

## Подробнее про нормализацию вектора
### Нормализация вектора движения

При разработке игр с управлением в реальном времени, особенно в изометрических играх, важно нормализовать векторы движения. Это позволяет сохранять постоянную скорость персонажа независимо от направления его движения.

#### Что такое нормализация вектора?

Вектор направления может иметь разную длину (величину), зависящую от направления движения. Чтобы персонаж всегда двигался с одинаковой скоростью, длина этого вектора должна быть равна 1. Процесс приведения длины вектора к единице называется **нормализацией**.

#### Пример

В контексте изометрической игры, где игрок может ходить влево, вправо, вверх и вниз, нормализация вектора движения выглядит следующим образом:

```gdscript
# motion - это вектор направления, заданный игроком
# speed - это скорость перемещения персонажа
set_velocity(motion.normalized() * speed)
```
`motion.normalized()` — нормализует вектор направления, чтобы его длина всегда была равна 1.
Умножение на `speed` гарантирует, что персонаж будет двигаться с постоянной скоростью независимо от того, движется ли он по диагонали или по одной оси.

Визуально выглядит как-то так: 

![image](https://github.com/user-attachments/assets/48b2a8cc-e16b-429a-919d-c79966006b88)

> [!TIP]
> Можно провести аналогию с экранным джойстиком в мобильных играх или на джойстике геймпада


> [!WARNING]
> Поскольку нормализация включает деление на длину вектора, нормализовать вектор с длиной 0 невозможно. Попытка сделать это обычно приведет к ошибке. Однако в GDScript вызов метода `normalized()` для вектора с длиной 0 оставит значение неизменным и предотвратит возникновение ошибки.

### Зачем это нужно?
Без нормализации персонаж будет двигаться быстрее при движении по диагонали, так как длина вектора движения по двум осям больше, чем по одной. Нормализация решает эту проблему, приводя вектор к единичной длине и обеспечивая равномерную скорость по всем направлениям.

```mermaid
graph TD;
    A[Начальное движение] --> B[Нормализация вектора];
    B --> C[Постоянная скорость];
```



<details>
	<summary>Сделайте ускорение, если много времени</summary>
	
Также можно добавить небольшое ускорение, можно такое как показано ниже

```gdscript
if Input.is_action_pressed("shift"):
		speed = 300
	else:
		speed = 200
```

А можно такой вариант с ограниченным временем действия

```gdscript
	if Input.is_action_pressed("run") and stamina > 5:
		speed = 80
		stamina -= 1
	else:
		speed = 50
		stamina += 1
		
	if stamina <= 6:
		speed = 50
```

Однако в таком случае нужно задать максимальное значение стамины и задать следующее условие

```gdscript
	if stamina > max_stamina:
		stamina = max_stamina
```
</details>


## Карта

### Создание базового игрового поля

Создадим базовое поле, на котором уже будет добавлять все остальное, в нашем случае это будет зеленое поле. Для этого создаем `TileMap`. В свойствах `TileMap` создаем `TileSet` после чего у нас появится сетка игрового поля. Т.к. мы создаем изометрический проект, `TileSet` нам нужно настроить под изометрию. Для этого изменим следующие параметры `TileSet`. 

![image](https://github.com/user-attachments/assets/1ff4de1c-77a3-4e1b-b28a-ee2483cfaa06)

Добавим сам тайл травы и зададим его размер в максимально допустимое значение, в нашем случае размер будет равен 128х128. Сам размер текстуры позволяет сделать такое разрешение + при создании карты будет нужно меньше тайлов, что хорошо влияет на оптимизацию игры.


![image](https://github.com/user-attachments/assets/8743d740-2bc9-4f39-8687-2b3cede9f2c1)

#### Как создать `TileSet` и отрисовать карту


![HowToCreateTileSets_1](https://github.com/user-attachments/assets/c3c9d9ab-e076-4faa-bb5c-abe501c6493f)

- Создаешь в параметре `TileSet` ресурс `TileSet`
- Выбираешь режим `Isometric` в параметре `Tile Shape`
- Выставляешь размеры тайла в параметре `Tile Size`
- Внизу посередине экрана выбираешь `Набор тайлов`, если он не выбран
- Перетаскиваешь нужную текстуру в окошко с тайлами
- Переходишь в `Карта тайлов` и там выбираешь нужный тайл


Закрашиваем область в который мы будет дальше работать травой и переходим к созданию зданий. Сделать это быстро можно зажав <kbd>Ctrl</kbd>+<kbd>Shift</kbd> и левой кнопкой выделить обрасть заполнение. Выглядеть будет примерно так:

![image](https://github.com/user-attachments/assets/36d3a00a-f8a6-4864-a595-cf32dbf7c64b)


### Создание зданий

Прежде чем создавать здания поменяем рендеринг текстур, нужно нам это для того, чтобы картинки были не мыльными, а пиксельными

Чтобы попасть в эти настройки нужно: `Проект` -> `Настройки проекта` -> `Основное` -> `Рендеринг` -> `Текстуры` 

![image](https://github.com/user-attachments/assets/bbafedf1-6c0d-4ca9-a87d-9d0c700c93ae)


>[!NOTE]
>В Godot различие между режимами рендеринга `nearest` и `linear` связано с тем, как текстуры интерполируются при масштабировании или изменении их размера.

1. Nearest (ближайший):
   - Использует метод ближайшего соседа для интерполяции пикселей.
   - При увеличении текстуры, цвет каждого пикселя берется из ближайшего пикселя оригинальной текстуры.
   - Это приводит к более резким и четким границам, что может создавать "пикселизацию".
   - Хорошо подходит для 2D-игр с пиксельной графикой, где важна четкость и стиль.
2. Linear (линейный):
   - Использует линейную интерполяцию для сглаживания цветов между пикселями.
   - При увеличении текстуры происходит смешивание цветов соседних пикселей, что создает более плавные переходы.
   - Это может сделать текстуру более размытой, но также более реалистичной.
   - Подходит для 3D-графики и игр, где важна плавность и детализация.

>[!Tip]
>Ты можешь не рассказывать всё так подробно, просто имей в виду, как это работает и в случае, если ребенок спросит - ты сможешь дать ответ.

Теперь для каждого здания нужно создать отдельную сцену родительским узлом которой будет `StaticBody2D`, а дочерними узлами будут `Sprite2D` и `CollisionPolygon2D`

Для `Sprite2D` используем текстурки зданий, а у `CollisionPolygon2D` задаем зону по которой не сможет ходить игрок, условно зону находящуюся под окнами первого этажа. Это нам позволит в будущем сделать эффект того, что игрок заходит за здание

Необходимо сместить `Sprite2D` при помощи свойства `offset`. Значения этих смещений будут указаны в скриншотах в таблице ниже

>[!IMPORTANT]
> Важно донести до учеников зачем им делать смещение спрайта. Так как сортировка идет по центру самого спрайта, а при обычном изменении `position` смещается и сам центр, нам нужно сдвинуть спрайт, не сдвигая сам центр спрайта. Поэтому мы смещаем его при помощи `offset`.
>Можете даже показать им, как игра выглядит без смещения

Примеры зданий:

| Название  | Скриншот | 
| ------------- | ------------- |
| Обычный дом   | ![image](https://github.com/user-attachments/assets/311dbaa7-b49b-4ad2-b44d-b280c6e0e298) |
| Замок  | ![image](https://github.com/user-attachments/assets/211462f0-8157-495d-b5db-fa7aafcc1da9) | 
| Гостинница  | ![image](https://github.com/user-attachments/assets/a7efff69-a87a-4ab8-ad01-e3812e68e116) | 
| Торговцы | ![image](https://github.com/user-attachments/assets/5f1df884-e19d-4240-a0bd-3b22cfa0f94f) | 
| Таверна | ![image](https://github.com/user-attachments/assets/8f049791-5532-4918-b2f7-e5da8b56f0ff) | 

Другие здания можете подобрать самостоятельно или дать эту работу ученикам. Если не выставить смещение (offset), то игрок будет некорректно заходить за здания и выставляться на передний план.
Теперь можно расставить эти здания по нашей карте, как делать это зависит от фантазии ученика, пример того как можно расставить ниже (для всех зданий нужно создать узел `Node2D` в котором будут хранится все здания и в будущем игрок и NPC)

![image](https://github.com/Sindikaty/byteschool/assets/158248099/747376c6-6f29-4a61-a099-5c2c53ff2c36)

### Создание дорожек

Для дорожек нам нужен еще один `TileMap` со следующими параметрами

![image](https://github.com/Sindikaty/byteschool/assets/158248099/22f8813e-a7be-4423-8157-4ec4c1913f28)


Добавим тайл дорожки и зададим его размер примерно в такие значение, их можно подобрать по желанию ученика

![image](https://github.com/Sindikaty/byteschool/assets/158248099/f425f890-51a8-4de3-9afb-56f9bf78cfca)

В результате мы получим примерно следующее:

![image](https://github.com/Sindikaty/byteschool/assets/158248099/cc79d761-d492-4ad1-af33-1af0ce036e41)




## Последние штрихи

Теперь для корректного отображения игрока проходящего рядом со зданиями включим параметр `Y Sort Enabled` у `Node2D`, который будет сортировать все дочерние элементы по высоте. 

![image](https://github.com/user-attachments/assets/89f80c37-d05b-4e7e-9c1c-ea24484a1c35)


Это позволит создать эффект того, что игрок заходит за здание

![image](https://github.com/Sindikaty/byteschool/assets/158248099/e3ab41fb-24fa-47c1-a5d0-df79d7e43d69)


# Итоги урока
- Ученики поработали со знакомым TileMapLayer, но с его новым функционалом
- Создали персонажа, который умеет заходить за здания, где его не будет видно
- Создали сами здания за которые может заходить игрок
- Кто не знал что такое нормализация вектора - узнали, что это


# Допы

В случае, если у вас остается много времени или ученикам хочется реализовать что-то другое, то можете дать им следующий материал

<details>

	
<summary>Можно сделать управление мышкой</summary>

 
```gdscript
var speed = 100
var stop = Vector2()

func _physics_process(delta):
	var agent = $NavigationAgent2D2
	var next = agent.get_next_path_position()
	agent.target_position = stop
	velocity = position.direction_to(next)*speed
	
	if not agent.is_navigation_finished():
		#update_animation(velocity)
		move_and_slide()
	#else:
		#animated_sprite.play("idle_down")
		
func _input(event):
	if InputEventMouseButton and event.is_pressed():
		stop = get_global_mouse_position()
```
Анимашки

```gdscript
@onready var animated_sprite = $AnimatedSprite2D

func update_animation(velocity):
	if velocity.x > 0:
		animated_sprite.flip_h = false
		animated_sprite.play("walk_down")
	elif velocity.x < 0:
		animated_sprite.flip_h = true
		animated_sprite.play("walk_down")
	elif velocity.y < 0:
		animated_sprite.play("walk_down")
	elif velocity.y > 0:
		animated_sprite.play("walk_down")
 ```

Игроку, который управляется через мышь необходимо добавить узел `NavigationAgent2D`

## Карта, если делаем управление игроком через мышь

Но тогда для управления игроком необходимо сделать навигационный слой для `TileMapLayer`

![image](https://github.com/user-attachments/assets/cbdf122a-52ac-45e0-8bd3-26b1185c31c9)

После того, как вы добавите слой - заходите в `Набор тайлов` внизу посередине и делаете следующее:
1. Выставляете образ будущей коллизии слева, расставляете вершины коллизии
2. С помощью ЛКМ выделяете все тайлы, где нужна эта коллизия


![Navigation](https://github.com/user-attachments/assets/7e0f53a2-a9af-4d0d-a7d6-8705ad0f3d40)

</details>







