# 2 Урок

## Краткое содержание
- Создание изометрической [карты](#карта) разного уровня сложности. С несколькими слоями - для хардов, с одним - для медиум и изиков.

# Карта

### Создание базового игрового поля

Создадим базовое поле, на котором уже будет добавлять все остальное, в нашем случае это будет зеленое поле. Для этого создаем `TileMap`. В свойствах `TileMap` создаем `TileSet` после чего у нас появится сетка игрового поля. Т.к. мы создаем изометрический проект, `TileSet` нам нужно настроить под изометрию. Для этого изменим следующие параметры `TileSet`. 

![image](https://github.com/user-attachments/assets/1ff4de1c-77a3-4e1b-b28a-ee2483cfaa06)

Добавим сам тайл травы и зададим его размер в максимально допустимое значение, в нашем случае размер будет равен 128х128. Сам размер текстуры позволяет сделать такое разрешение + при создании карты будет нужно меньше тайлов, что хорошо влияет на оптимизацию игры.


![image](https://github.com/user-attachments/assets/8743d740-2bc9-4f39-8687-2b3cede9f2c1)

#### Как создать `TileSet` и отрисовать карту


![HowToCreateTileSets_1](https://github.com/user-attachments/assets/c3c9d9ab-e076-4faa-bb5c-abe501c6493f)

- Создаешь в параметре `TileSet` ресурс `TileSet`
- Выбираешь режим `Isometric` в параметре `Tile Shape`
- Выставляешь размеры тайла в параметре `Tile Size`
- Внизу посередине экрана выбираешь `Набор тайлов`, если он не выбран
- Перетаскиваешь нужную текстуру в окошко с тайлами
- Переходишь в `Карта тайлов` и там выбираешь нужный тайл


Закрашиваем область в который мы будет дальше работать травой и переходим к созданию зданий. Сделать это быстро можно зажав <kbd>Ctrl</kbd>+<kbd>Shift</kbd> и левой кнопкой выделить обрасть заполнение. Выглядеть будет примерно так:

![image](https://github.com/user-attachments/assets/36d3a00a-f8a6-4864-a595-cf32dbf7c64b)


### Создание зданий

Прежде чем создавать здания поменяем рендеринг текстур, нужно нам это для того, чтобы картинки были не мыльными, а пиксельными

Чтобы попасть в эти настройки нужно: `Проект` -> `Настройки проекта` -> `Основное` -> `Рендеринг` -> `Текстуры` 

![image](https://github.com/user-attachments/assets/bbafedf1-6c0d-4ca9-a87d-9d0c700c93ae)


>[!NOTE]
>В Godot различие между режимами рендеринга `nearest` и `linear` связано с тем, как текстуры интерполируются при масштабировании или изменении их размера.

1. Nearest (ближайший):
   - Использует метод ближайшего соседа для интерполяции пикселей.
   - При увеличении текстуры, цвет каждого пикселя берется из ближайшего пикселя оригинальной текстуры.
   - Это приводит к более резким и четким границам, что может создавать "пикселизацию".
   - Хорошо подходит для 2D-игр с пиксельной графикой, где важна четкость и стиль.
2. Linear (линейный):
   - Использует линейную интерполяцию для сглаживания цветов между пикселями.
   - При увеличении текстуры происходит смешивание цветов соседних пикселей, что создает более плавные переходы.
   - Это может сделать текстуру более размытой, но также более реалистичной.
   - Подходит для 3D-графики и игр, где важна плавность и детализация.

>[!Tip]
>Ты можешь не рассказывать всё так подробно, просто имей в виду, как это работает и в случае, если ребенок спросит - ты сможешь дать ответ.

Теперь для каждого здания нужно создать отдельную сцену родительским узлом которой будет `StaticBody2D`, а дочерними узлами будут `Sprite2D` и `CollisionPolygon2D`

Для `Sprite2D` используем текстурки зданий, а у `CollisionPolygon2D` задаем зону по которой не сможет ходить игрок, условно зону находящуюся под окнами первого этажа. Это нам позволит в будущем сделать эффект того, что игрок заходит за здание

Необходимо сместить `Sprite2D` при помощи свойства `offset`. Значения этих смещений будут указаны в скриншотах в таблице ниже

>[!IMPORTANT]
> Важно донести до учеников зачем им делать смещение спрайта. Так как сортировка идет по центру самого спрайта, а при обычном изменении `position` смещается и сам центр, нам нужно сдвинуть спрайт, не сдвигая сам центр спрайта. Поэтому мы смещаем его при помощи `offset`.
>Можете даже показать им, как игра выглядит без смещения

Примеры зданий:

| Название  | Скриншот | 
| ------------- | ------------- |
| Обычный дом   | ![image](https://github.com/user-attachments/assets/311dbaa7-b49b-4ad2-b44d-b280c6e0e298) |
| Замок  | ![image](https://github.com/user-attachments/assets/211462f0-8157-495d-b5db-fa7aafcc1da9) | 
| Гостинница  | ![image](https://github.com/user-attachments/assets/a7efff69-a87a-4ab8-ad01-e3812e68e116) | 
| Торговцы | ![image](https://github.com/user-attachments/assets/5f1df884-e19d-4240-a0bd-3b22cfa0f94f) | 
| Таверна | ![image](https://github.com/user-attachments/assets/8f049791-5532-4918-b2f7-e5da8b56f0ff) | 

Другие здания можете подобрать самостоятельно или дать эту работу ученикам. Если не выставить смещение (offset), то игрок будет некорректно заходить за здания и выставляться на передний план.
Теперь можно расставить эти здания по нашей карте, как делать это зависит от фантазии ученика, пример того как можно расставить ниже (для всех зданий нужно создать узел `Node2D` в котором будут хранится все здания и в будущем игрок и NPC)

![image](https://github.com/Sindikaty/byteschool/assets/158248099/747376c6-6f29-4a61-a099-5c2c53ff2c36)

### Создание дорожек

Для дорожек нам нужен еще один `TileMap` со следующими параметрами

![image](https://github.com/Sindikaty/byteschool/assets/158248099/22f8813e-a7be-4423-8157-4ec4c1913f28)


Добавим тайл дорожки и зададим его размер примерно в такие значение, их можно подобрать по желанию ученика

![image](https://github.com/Sindikaty/byteschool/assets/158248099/f425f890-51a8-4de3-9afb-56f9bf78cfca)

В результате мы получим примерно следующее:

![image](https://github.com/Sindikaty/byteschool/assets/158248099/cc79d761-d492-4ad1-af33-1af0ce036e41)




## Последние штрихи

Теперь для корректного отображения игрока проходящего рядом со зданиями включим параметр `Y Sort Enabled` у `Node2D`, который будет сортировать все дочерние элементы по высоте. 

![image](https://github.com/user-attachments/assets/89f80c37-d05b-4e7e-9c1c-ea24484a1c35)


Это позволит создать эффект того, что игрок заходит за здание

![image](https://github.com/Sindikaty/byteschool/assets/158248099/e3ab41fb-24fa-47c1-a5d0-df79d7e43d69)


# Итоги урока
- Ученики поработали со знакомым TileMapLayer, но с его новым функционалом
- Создали сами здания за которые может заходить игрок


# Допы

<details>

	
<summary>Можно сделать управление мышкой</summary>

 
```gdscript
var speed = 100
var stop = Vector2()

func _physics_process(delta):
	var agent = $NavigationAgent2D2
	var next = agent.get_next_path_position()
	agent.target_position = stop
	velocity = position.direction_to(next)*speed
	
	if not agent.is_navigation_finished():
		#update_animation(velocity)
		move_and_slide()
	#else:
		#animated_sprite.play("idle_down")
		
func _input(event):
	if InputEventMouseButton and event.is_pressed():
		stop = get_global_mouse_position()
```
Анимашки

```gdscript
@onready var animated_sprite = $AnimatedSprite2D

func update_animation(velocity):
	if velocity.x > 0:
		animated_sprite.flip_h = false
		animated_sprite.play("walk_down")
	elif velocity.x < 0:
		animated_sprite.flip_h = true
		animated_sprite.play("walk_down")
	elif velocity.y < 0:
		animated_sprite.play("walk_down")
	elif velocity.y > 0:
		animated_sprite.play("walk_down")
 ```

Игроку, который управляется через мышь необходимо добавить узел `NavigationAgent2D`

## Карта, если делаем управление игроком через мышь

Но тогда для управления игроком необходимо сделать навигационный слой для `TileMapLayer`

![image](https://github.com/user-attachments/assets/cbdf122a-52ac-45e0-8bd3-26b1185c31c9)

После того, как вы добавите слой - заходите в `Набор тайлов` внизу посередине и делаете следующее:
1. Выставляете образ будущей коллизии слева, расставляете вершины коллизии
2. С помощью ЛКМ выделяете все тайлы, где нужна эта коллизия


![Navigation](https://github.com/user-attachments/assets/7e0f53a2-a9af-4d0d-a7d6-8705ad0f3d40)

</details>
