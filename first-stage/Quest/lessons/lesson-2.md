# Урок 2

## Содержание
- Создание обычного [NPC](#обычный-бот)
- Создание [NPC](#квестгивер), с которым можно будет взаимодействовать
- [Допы](#допы)

## Обычный бот
### Подготовка сцены бота

Создадим новую сцену для NPC (Non-player character) не дающего заданий. 

Основным узлом будет `CharacterBody2D` и к нему мы присоединяем `AnimatedSprite2D` и `CollisionShape2D`. Анимации и коллизию делаем как у игрока полсе чего переходим к скрипту.

![image](https://github.com/user-attachments/assets/1db6af3f-d422-4a10-9051-468f05dc4254)

> Как можно заметить - у ботов похожий спрайт, следовательно, то же самое смещение

Для реализации нам понадобятится 4 переменные

```gdscript
var move_dir = Vector2.ZERO # переменная в которой храним направление бота
var move_speed = 50 # его скорость
var time_to_change_dir = 2 # время для смены направления движения (можете сделать его рандомным)
var timer = 0 # таймер, который будет доходить до значения time_to_change_dir, а затем сбрасываться
```

После чего в process прописываем случайное перемещение бота каждые 2 секунды

```gdscript
func _physics_process(delta): # метод, который вы должны использовать для всего, что предполагает использование физического движка
	timer += delta;
	if timer >= time_to_change_dir:
		timer = 0
		move_dir = Vector2(randf_range(-1, 1), randf_range(-1, 1)).normalized()
	
	set_velocity(move_dir * move_speed)
	move_and_slide()

func _process(delta): # а этот метод можно использовать для обработки анимаций и прочих операций, которые не обрабатывают физику
	if move_dir == Vector2(0,0): # если бот стоит на месте, то его анимация будет следующая:
		move_anim(move_dir) # имя метода ниже и в него записан аргумент, который передается в параметр метода move_anim()
	else: # иначе:
		move_anim(move_dir) # имя метода ниже и в него записан аргумент, который передается в параметр метода move_anim()
	
	

func move_anim(move_dir: Vector2): # метод внутри которого объявляется параметр с типом Vector2, который метод хочет получить и в него мы передаем значение направления бота
	if move_dir == Vector2.ZERO: # далее мы исходя из данных move_dir меняем анимацию бота
		$AnimatedSprite2D.play("idle")
	if move_dir.x > 0:
		$AnimatedSprite2D.flip_h = false
	else:
		$AnimatedSprite2D.flip_h = true
		
	if move_dir.y > 0:
		$AnimatedSprite2D.play("walk")
	else:
		$AnimatedSprite2D.play("walk_up")
```

>[!IMPORTANT]
>Параметры — это переменные, задаваемые при создании функции, которые служат для хранения данных, используемых внутри этой функции. Аргументы — это конкретные значения, передаваемые функции во время её вызова. Проще говоря, если рассматривать функцию как рецепт, то параметры представляют собой список ингредиентов, а аргументы — это те ингредиенты, которые вы добавляете в процессе приготовления. 

```gdscript
# это пример
func pie(apple: int):  # Здесь 'apple' — это параметр функции
    print("У вас есть ", apple, " яблок(а) для пирога.")

# Вызов функции с аргументом
pie(5)  # Здесь '5' — это аргумент, передаваемый функции
```

На уровне добавляем отдельный узел Node2D где будут хранится все NPC, после чего присоединяем туда наших ботов.
![image](https://github.com/user-attachments/assets/b1cc1e49-c488-454a-b1ab-fa5dad5720dc)

> Как видно, `Ordering`, а точнее свойство `Y Sort Enabled` - включен. Поэтому будет работать сортировка по Y у всех дочерних элементов 

## Говорящий NPC

Следующий подраздел начнем с создания персонажа у которого мы можем получить квест. К NPC добавим его анимацию, например так:

![QuestGiver gif](https://github.com/user-attachments/assets/0e3b5a80-82e0-444d-a7d9-ff07f405b89a)


>[!TIP]
>Дети уже к концу курса должны быть на опыте, поэтому можно спокойно отдать часть с настройкой анимации на самостоятельную реализацию.
>Коллизии лучше сделать с ними, так как их настройка будет зависеть от расположения этого персонажа

Используем мы `CollisionPolygon2D` потому что через него можно задать необходимую область для персонажа, но если ребенок совсем Easy, то можно сделать `CollisionShape2D`. 

Как работать с `CollisionPolygon2D`:

![MakingCollisions](https://github.com/user-attachments/assets/b51c6994-d4ee-496f-8559-24d0f95d6bd2)



Теперь нам нужно создать сам диалог с продавцом, для этого создадим `CanvasLayer` и в нем узел `Control`.
![image](https://github.com/user-attachments/assets/52e9814e-2976-426c-b8b7-25bdf666cafd)


>[!TIP]
>Для удобства привыкайте переименовывать узлы, чтобы было понятнее и проще работать с ними в будущем.


Также нам понадобятся следующие элементы:
* `Panel` 2x (рамка диалогового окна и рамка текста)
* `Label` 2x (Имя персонажа и текст самого NPC)
* `Button` 2x (Выбор ответа)
* `AnimatedSprite2D` (Персонаж)

И приходим примерно к этому:

![image](https://github.com/user-attachments/assets/b9fecb72-ae51-4c65-9983-7075cda0e6fc)

>[!NOTE]
>Конечно вы можете сделать свой вариант. И дети тоже могут. Проявите свою творческую сторону!

![image](https://github.com/user-attachments/assets/9dd459dc-46e4-46aa-a5bc-bc11aec4a866)

>Такой вариант может быть даже лучше, сэкономит место, но вы в любом случае можете выбрать сами.

![image](https://github.com/user-attachments/assets/ba16a092-dcf6-4ecd-90a4-0662664cd4f9)


Прикрепляем скрипт и присоединяем сигналы на вход и выход из зоны персонажа и в них прописываем включение/выключение диалога соответственно

```gdscript
var in_area = false # эта переменная будет проверять в области ли игрок

func _process(delta):
	if in_area == true: # здесь проверяется в области ли игрок
		%QuestGiverWindow2.visible = true # обращение по уникальному имени узла
	else:
		%QuestGiverWindow2.visible = false


func _on_body_entered(body):
	if body.name == "Player": # проверка на имя узла, проверяйте имя узла игрока! Не сцены!
		in_area = true # если выражение выше является истинным, то тогда включаем эту переменную
		


func _on_body_exited(body):
	if body.name == "Player": # всё та же проверка
		in_area = false # здесь всё наоборот
```

>[!WARNING]
>Ты должно быть заметил, что в скрипте используется не <kbd>$</kbd> при обращении к узлу, а <kbd>%</kbd>. Сделано это для доступа к узлу по уникальному имени, т.е. можно обращаться к узлу, независимо от пути к этому узлу.

Делается это следующим образом:

![UniqueName](https://github.com/user-attachments/assets/29c851a7-7850-40cb-ba49-2ef9b44464f3)



### Программируем интерфейс квестгивера

Когда мы переименовали интерфейс (`Control`) и задали ему уникальное имя - можно прикреплять скрипт

Хранить квесты, для относительной простоты, мы будем внутри данного интерфейса.

Полный скрипт для ознакомления представлен ниже.

 Начать можете с чего-то подобного:

```gdscript
var quest = [] # здесь мы будем хранить квесты
signal quest_accepted # нужен будет для передачи сигнала в узел с предметами, чтобы там произошел спавн объектов

func _process(delta): 
	if quest.has("Собери хлам"): # если в списке есть такой квест, то будет следующее
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # можете переименовать Label и задать ему уникальное имя, чтобы сократить обращение к узлу
		Ты бы знал, как сильно выручил меня!"

func _on_option_1_pressed(): # прикрепляете сигнал от кнопки
	if quest.is_empty() and !quest.has("Собери хлам"): # если в квесте пусто и там нет принимаемого квеста
		quest.append("Собери хлам") # принимаем его и добавляем в quest
		


func _on_option_2_pressed(): # если отказываемся, то просто выключаем область для нас
	%QuestGiver.in_area = false
```

А прийти к этому:

```gdscript
extends Control

var quest = []
signal quest_accepted

func _process(delta): # вы прописываете здесь все необходимые ветвления и условия для вашего квеста. Более-менее универсальный вариант представлен здесь
	if quest.has("Собери хлам"): # проверяете есть ли в массиве такой элемент
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # в случае успеха проверки условия будет выполняться данный код
		Ты бы знал, как сильно выручил меня!" # текст можно переносить на разные строки
	if quest.has("Отнеси обратно склянку"):
		$PanelOutside/PanelInside/Label.text = "Спасибо огромное! 
		Теперь я не погибну от рук берсерка."
		$Option_1.text = "Вот, держи свой эстус"
		$Option_2.text = "Хотя... Он мой"
	if quest.has("Задание от Кассандры: Выполнено"):
		$PanelOutside/PanelInside/Label.text = "Теперь меня никто
		не остановит!"
	if quest.has("Задание от Кассандры: Вы плохой человек"):
		$PanelOutside/PanelInside/Label.text = "Уходи. Глаза бы мои
		тебя не видели. Так ведь нельзя."
		$Option_1.text = "Понял. Ухожу"
		$Option_2.text = "Бывает такое"


func _on_option_1_pressed():
	if quest.is_empty() and !quest.has("Собери хлам"):
		quest.append("Собери хлам")
		emit_signal("quest_accepted")
	if quest.has("Отнеси обратно склянку"):
		quest.clear()
		quest.append("Задание от Кассандры: Выполнено")


func _on_option_2_pressed():
	if quest.has("Отнеси обратно склянку"):
		quest.clear()
		quest.append("Задание от Кассандры: Вы плохой человек")
	%QuestGiver.in_area = false

```
>[!Tip]
>Внимательно почитай код, чтобы понять что и зачем нужно. На самом деле всё не так сложно

Начнем с простого:
```gdscript
var quest = []

```

>[!WARNING]
>Тут надо внести ясность: списки и массивы работают по-разному в GDScript и Python.
>
>Так в Python: Список = динамическая коллекция; массив = ограниченная коллекция одного типа
>
>GDScript: Массив = список (одинаковая функция).

#### Внесем еще больше ясности, для общего развития

##### GDScript

- Массив: Это структура данных, которая может хранить упорядоченные элементы. В GDScript массивы динамические, и их размер может изменяться. Элементы могут быть разных типов (числа, строки и т.д.).

- Список: В GDScript нет отдельного типа "список". Массивы выполняют ту же функцию, что и списки в других языках.

##### Python

- Список: Это встроенный тип данных, который также хранит упорядоченные элементы. Списки динамические, могут содержать элементы разных типов и поддерживают множество методов для манипуляций (добавление, удаление, сортировка).

- Массив: В Python обычно используется модуль array, который предоставляет более ограниченные возможности по сравнению со списками. Массивы требуют, чтобы все элементы были одного типа, и чаще используются для работы с числовыми данными.


> Говорить можешь так: "Сперва нам нужно создать переменную, которая будет хранить в себе квесты. Тип данных у этой переменной - массив. Список позволит нам хранить множество значений, но мы будем использовать текстовый.

После этого присоединяете сигналы от кнопок, сразу оба. И пишете следующий код:

```gdscript
func _on_option_1_pressed():
	if quest.is_empty() and !quest.has("Тут пишете имя квеста"):
		quest.append("Тут пишете имя квеста")
		


func _on_option_2_pressed():
	%QuestGiver.in_area = false
```
>Можешь сказать: "Логика такая, ребята: на кнопку с принятием квеста мы проверяем пусто ли в массиве с квестами и нет ли там нашего квеста.
>
>Если нет, то добавляем его в массив и в дальнейшем сможем с ним работать."

Как добавили кнопки и квест - можете приступать к проверке наличия квеста в массиве.
Код:
```gdscript
func _process(delta):
	if quest.has("Тут пишете имя квеста"):
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # просто для примера, можете свое придумать, можете взять
		Ты бы знал, как сильно выручил меня!"
```

### Создание предмета для квеста

![image](https://github.com/user-attachments/assets/764a76e6-dec3-498c-a976-8036368d147f)

> Это может быть любой другой предмет. Зависит от истории ученика.

Из чего состоит подбираемый предмет:
![image](https://github.com/user-attachments/assets/fe740b3e-772c-4234-83ae-1f79e4b8575d)

Скрипт достаточно простой:

```gdscript
func _on_body_entered(body): # сигнал, который исходит от самого узла
	if body.name == "Player": # проверка имени игрока
		body.item_collected() # вызов метода у тела
		queue_free() # удаление предмета
```
Сигнал прикрепляете `body_entered` к самому скрипту предмета

### Создание узла для предметов

Создайте новый Node2D и переименуйте его, чтобы помещать туда в дальнейшем объекты, которые мы будем спавнить из скрипта

![image](https://github.com/user-attachments/assets/6edec8ca-5bdc-41f5-87ca-7c2dcc76257e)

И сразу крепите к нему скрипт

```gdscript
# как обычно - сперва полный скрипт, чтобы было понимание того, что мы делаем
# а дальше по порядку

@export var glass_scene : PackedScene # сюда мы положим сцену
@export var min_glass = 1 # эти переменные опциональны, на случай, если вы будете с хардами делать генерацию нескольких предметов
@export var max_glass = 5 # 


func _on_quest_giver_window_quest_accepted(): # сигнал, который приходит от интерфейса квеста
	spawn_item() # вызов метода, который будет спавнить предметы

# вариант 1
func spawn_item(): # вы можете создать такой метод
	var glass = glass_scene.instantiate() # инстанцируем сцену предмета
	glass.position = Vector2(randf_range(100, 100),randf_range(100, 100)) # задаем случайную позицию. Можно задать спавн в случайной точке или просто создать спавн в каком-то конкретном месте
	add_child(glass)
```

Можете попробовать вариант с конкретной точкой (так будет меньше багов)
```gdscript

# вариант 2
func spawn_item(): # или такой метод
	var glass = glass_scene.instantiate() # инстанцируем сцену предмета
	glass.position = $GlassSpawnPoint.position # можете задать спавн в конкретной точке
	add_child(glass)
```

Задаете конкретную позицию узлу Marker2D и переименовываете его.

![image](https://github.com/user-attachments/assets/1885b066-e4b3-419f-9d79-2c68deaf019c)

Остается только проверить подбор предмета. 

