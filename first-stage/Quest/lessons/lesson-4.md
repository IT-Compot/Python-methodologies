# 4 Урок

## Содержание
- [Квестгивер](#квестгивер)
- [Скрипт квестгивера](#скрипт-квестгивера)


## Квестгивер

Следующий подраздел начнем с создания персонажа у которого мы можем получить квест. К NPC добавим его анимацию, например так:

![QuestGiver gif](https://github.com/user-attachments/assets/0e3b5a80-82e0-444d-a7d9-ff07f405b89a)


>[!TIP]
>Дети уже к концу курса должны быть на опыте, поэтому можно спокойно отдать часть с настройкой анимации на самостоятельную реализацию.
>Коллизии лучше сделать с ними, так как их настройка будет зависеть от расположения этого персонажа

Используем мы `CollisionPolygon2D` потому что через него можно задать необходимую область для персонажа, но если ребенок совсем Easy, то можно сделать `CollisionShape2D`. 

Как работать с `CollisionPolygon2D`:

![MakingCollisions](https://github.com/user-attachments/assets/b51c6994-d4ee-496f-8559-24d0f95d6bd2)



Теперь нам нужно создать сам диалог с продавцом, для этого используем ранее созданный `CanvasLayer` и в нем узел `Control`.
![image](https://github.com/user-attachments/assets/52e9814e-2976-426c-b8b7-25bdf666cafd)


>[!TIP]
>Для удобства привыкайте переименовывать узлы, чтобы было понятнее и проще работать с ними в будущем.


Также нам понадобятся следующие элементы:
* `Panel` 2x (рамка диалогового окна и рамка текста)
* `Label` 2x (Имя персонажа и текст самого NPC)
* `Button` 2x (Выбор ответа)
* `AnimatedSprite2D` (Персонаж)

И приходим примерно к этому:

![image](https://github.com/user-attachments/assets/b9fecb72-ae51-4c65-9983-7075cda0e6fc)

>[!NOTE]
>Конечно вы можете сделать свой вариант. И дети тоже могут. Проявите свою творческую сторону!

![image](https://github.com/user-attachments/assets/9dd459dc-46e4-46aa-a5bc-bc11aec4a866)

>Такой вариант может быть даже лучше, сэкономит место, но вы в любом случае можете выбрать сами.

![image](https://github.com/user-attachments/assets/ba16a092-dcf6-4ecd-90a4-0662664cd4f9)

### Скрипт квестгивера

Прикрепляем скрипт и присоединяем сигналы на вход и выход из зоны персонажа и в них прописываем включение/выключение диалога соответственно

```gdscript
var in_area = false # эта переменная будет проверять в области ли игрок

func _process(delta):
	if in_area == true: # здесь проверяется в области ли игрок
		%QuestGiverWindow2.visible = true # обращение по уникальному имени узла
	else:
		%QuestGiverWindow2.visible = false


func _on_body_entered(body):
	if body.name == "Player": # проверка на имя узла, проверяйте имя узла игрока! Не сцены!
		in_area = true # если выражение выше является истинным, то тогда включаем эту переменную
		


func _on_body_exited(body):
	if body.name == "Player": # всё та же проверка
		in_area = false # здесь всё наоборот
```

>[!WARNING]
>Ты должно быть заметил, что в скрипте используется не <kbd>$</kbd> при обращении к узлу, а <kbd>%</kbd>. Сделано это для доступа к узлу по уникальному имени, т.е. можно обращаться к узлу, независимо от пути к этому узлу.

Делается это следующим образом:

![UniqueName](https://github.com/user-attachments/assets/29c851a7-7850-40cb-ba49-2ef9b44464f3)


## Интерфейс квестгивера

Далее мы добавляем узел интерфейса (`Control`), переименовали его в `QuestGiverInterface` или что-то похожее и задали ему уникальное имя. После - прикрепляем скрипт.
В этом узле мы будем обрабатывать логику выдачи квеста и работу с ним в принципе.

Полные скрипты для ознакомления представлены ниже.

Начать можете с чего-то подобного:

```gdscript
# quest_giver_interface.gd
@onready var ui = %UI # ссылка на узел, где мы будем хранить квесты
signal quest_accepted # нужен будет для передачи сигнала в узел с предметами, чтобы там произошел спавн объектов

func _process(delta): 
	if ui.quest.has("Собери склянку"): # если в списке есть такой квест, то будет следующее
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # можете переименовать Label и задать ему уникальное имя, чтобы сократить обращение к узлу
		Ты бы знал, как сильно выручил меня!"

func _on_option_1_pressed(): # прикрепляете сигнал от кнопки
	if ui.quest.is_empty() or !ui.quest.has("Собери склянку") and !ui.quest.has("Отнеси обратно склянку"): # если в квесте пусто или там нет принимаемых квестов
		ui.quest.append("Собери склянку") # принимаем его и добавляем в quest
		


func _on_option_2_pressed(): # если отказываемся, то просто выключаем область для нас
	%QuestGiver.in_area = false # не забывайте про уникальные имена узлов, чтобы путь к ним был значительно короче
```

А прийти к этому:

>[!Warning]
>Ваш код не обязательно должен быть, как код ниже. Это лишь возможный вариант, к которому можно прийти. В этом коде представлены возможные диалоги и ветвления.

```gdscript
# quest_giver_interface.gd
extends Control

signal quest_accepted
@onready var ui = %UI

func _process(delta): # вы прописываете здесь все необходимые ветвления и условия для вашего квеста. Более-менее универсальный вариант представлен здесь
	if ui.quest.has("Собери склянку"): # проверяете есть ли в массиве такой элемент
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # в случае успеха проверки условия будет выполняться данный код
		Ты бы знал, как сильно выручил меня!" # текст можно переносить на разные строки
	if ui.quest.has("Отнеси обратно склянку"):
		$PanelOutside/PanelInside/Label.text = "Спасибо огромное! 
		Теперь я не погибну от рук берсерка."
		$Option_1.text = "Вот, держи свой эстус"
		$Option_2.text = "Хотя... Он мой"
	if ui.quest.has("Задание от Кассандры: Выполнено"):
		$PanelOutside/PanelInside/Label.text = "Теперь меня никто
		не остановит!"
	if ui.quest.has("Задание от Кассандры: Вы плохой человек"):
		$PanelOutside/PanelInside/Label.text = "Уходи. Глаза бы мои
		тебя не видели. Так ведь нельзя."
		$Option_1.text = "Понял. Ухожу"
		$Option_2.text = "Бывает такое"


func _on_option_1_pressed():
	if ui.quest.is_empty() or !ui.quest.has("Собери склянку") and !ui.quest.has("Отнеси обратно склянку"):
		ui.quest.append("Собери склянку")
		emit_signal("quest_accepted")
	if ui.quest.has("Отнеси обратно склянку"):
		ui.quest.erase("Отнеси обратно склянку")
		ui.quest.append("Задание от Кассандры: Выполнено")


func _on_option_2_pressed():
	if ui.quest.has("Отнеси обратно склянку"):
		ui.quest.erase("Отнеси обратно склянку")
		ui.quest.append("Задание от Кассандры: Вы плохой человек")
	%QuestGiver.in_area = false

```
>[!Tip]
>Внимательно почитай код, чтобы понять что и зачем нужно. На самом деле всё не так сложно

Начнем с простого:
```gdscript
@onready var ui = %UI # возможно так будет проще, чем каждый раз ставить знак процента

```

После этого присоединяете сигналы от кнопок, сразу оба. И пишете следующий код:

```gdscript
func _on_option_1_pressed():
	if ui.quest.is_empty() or !ui.quest.has("Тут пишете имя квеста, который не должен сейчас мешаться"):
		ui.quest.append("Тут пишете имя квеста")
		


func _on_option_2_pressed():
	%QuestGiver.in_area = false
```
>Можешь сказать: "Логика такая, ребята: на кнопку с принятием квеста мы проверяем пусто ли в массиве с квестами и нет ли там нашего квеста.
>
>Если нет, то добавляем его в массив и в дальнейшем сможем с ним работать."

Как добавили кнопки и квест - можете приступать к проверке наличия квеста в массиве.
Код:
```gdscript
func _process(delta):
	if ui.quest.has("Тут пишете имя квеста"):
		$PanelOutside/PanelInside/Label.text = "Отлично! Спасибо тебе большое! # просто для примера, можете свое придумать, можете взять
		Ты бы знал, как сильно выручил меня!"
```
<details>
	<summary>Небольшая памятка по методам массивов</summary>
	
#### Методы для работы с массивами

1. `append(value)`

Добавляет элемент в конец массива.

```gdscript
var my_array = []
my_array.append(5)  # Теперь my_array = [5]
my_array.append(10) # Теперь my_array = [5, 10]
```

2. `remove(index)`

Удаляет элемент по указанному индексу.
```gdscript
var my_array = [5, 10, 15]
my_array.remove(1)  # Удаляет элемент с индексом 1 (10)
# Теперь my_array = [5, 15]
```

3. `erase(value)`

Удаляет первое вхождение указанного значения из массива.
```gdscript
var my_array = [5, 10, 15, 10]
my_array.erase(10)  # Удаляет первое вхождение 10
# Теперь my_array = [5, 15, 10]
```

4. `has(value)`

Проверяет, содержится ли значение в массиве. Возвращает true или false.
```gdscript
var my_array = [5, 10, 15]
print(my_array.has(10))  # Вывод: true
print(my_array.has(20))  # Вывод: false
```

5. `clear()`

Очищает массив, удаляя все элементы.
```gdscript
var my_array = [5, 10, 15]
my_array.clear()  # Теперь my_array = []
```

6. `size()`

Возвращает количество элементов в массиве.
```gdscript
var my_array = [5, 10, 15]
print(my_array.size())  # Вывод: 3
```

7. `insert(index, value)`

Вставляет элемент по указанному индексу.

```gdscript
var my_array = [5, 10, 15]
my_array.insert(1, 7)  # Вставляет 7 на позицию с индексом 1
# Теперь my_array = [5, 7, 10, 15]
```

8. `sort()`

Сортирует массив (по возрастанию).
```gdscript
var my_array = [15, 5, 10]
my_array.sort()  # Теперь my_array = [5, 10, 15]
```
</details>


