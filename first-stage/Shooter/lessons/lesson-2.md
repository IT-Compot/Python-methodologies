## Урок 2

## Краткое содержание
- Создание пули
- Добавление бота

### Создание пули
<img src="https://github.com/IT-Compot/Python-methodologies/blob/main/first-stage/Shooter/images/bullet_pic.jpg" id="bullet_pic">

Создаем новую сцену и в качестве корневого узла используем `Area2D`.


Базово для создания пушки потребуются следующие узлы:

* `Area2D` - пули у нас будут сделаны из узла области
* `MeshInstance2D` - это узел, который позволяет вам отображать 2D-меши (сеточные объекты) в 2D-пространстве
* `CollisionShape2D` - узел коллизии
* `VisibleOnScreenNotifier2D` - это узел, который позволяет отслеживать, виден ли объект на экране камеры

Начнем с настройки меша. Вообще `MeshInstance2D` полезен, когда вам нужно отобразить 2D-объекты с высокой детализацией или когда вы хотите использовать возможности 3D-графики в 2D-контексте, но в нашем случае можно просто сделать 2D-сферу и использовать её в качестве пули.

В параметре `Mesh` выбираем фигуру, а потом подбираем по размеру. 
>[!Tip]
>Можете добавить копию меша на сцену игрока или наоборот добавить игрока в сцену с пулей, чтобы посмотреть на пропорции.

Пример на скрине ниже:

<img src="https://github.com/IT-Compot/Python-methodologies/blob/main/first-stage/Shooter/images/mesh_screenshot.jpg">

Добавляем форму коллизии и настраиваем область `VisibleOnScreenNotifier2D` и получим что-то вроде [этого](#bullet_pic)



#### Перейдем к скрипту

Для начала взглянем на полный скрипт пули

```gdscript
extends Area2D  # Наследуемся от Area2D (объект, который может реагировать на столкновения)

const SPEED := 800  # Константа скорости движения (800 пикселей в секунду)

var direction: Vector2 = Vector2.ZERO  # Вектор направления движения, изначально (0,0)

func _physics_process(delta: float) -> void:
    # Определяем направление движения, основываясь на текущем угле поворота (rotation)
    var direction: Vector2 = Vector2.RIGHT.rotated(rotation)  

    # Перемещаем объект в направлении `direction` с учётом скорости и времени кадра
    position += direction * SPEED * delta

func _on_body_entered(body):
	queue_free()  # Уничтожить пулю при столкновении

func _on_visible_on_screen_notifier_2d_screen_exited(): # Метод вызывается, если пуля покидает поле зрения камеры
	print("bullet is deleted")
	# удаляем пулю
	queue_free() 
```

Теперь построчно и начнем с основного: движение пули.

1. `extends Area2D`
Этот код указывает, что наш скрипт наследуется от Area2D – специального узла, который используется для обработки столкновений и зон триггеров. Это значит, что объект с этим скриптом может реагировать на пересечения с другими объектами (например, наш случай, пуля может пересекать врагов).

2. `const SPEED := 800`
Объявляется константа `SPEED`, которая задаёт скорость движения объекта.

`const` означает, что значение нельзя изменить во время работы игры.
`:=` – сокращённая форма присваивания и указания типа. Двоеточие задаёт тип переменной. Если тип не указан, `Godot` попытается его вывести автоматически.

| Особенность            | Статическая типизация (`: тип`)         | Динамическая типизация (`var`)       |
|------------------------|---------------------------------|--------------------------------|
| **Объявление переменной** | `var speed: int = 10`         | `var speed = 10`               |
| **Безопасность типов**  | Проверяется **на этапе компиляции**, меньше ошибок в рантайме | Ошибки возможны **во время выполнения** |
| **Производительность**  | Быстрее, так как тип известен сразу | Чуть медленнее, так как тип проверяется в рантайме |
| **Гибкость**           | Жёстко определённый тип, нельзя изменить (`int` → `string` вызовет ошибку) | Можно изменить тип в любой момент (`speed = "fast"`) |
| **Автодополнение (IntelliSense)** | Работает лучше, так как Godot знает точный тип | Может работать хуже, так как тип неизвестен |
| **Отладка**            | Легче находить ошибки типов | Возможны неожиданные ошибки, если тип изменился |
| **Использование в GDScript** | Рекомендуется для **критичных участков кода**, например, в физике или AI | Удобно для **гибких данных**, например, в UI или JSON |
| **Пример использования** | `var health: int = 100` (не изменится на `string`) | `var player_data = { "name": "Hero", "score": 10 }` |


3. `var direction: Vector2 = Vector2.ZERO`
Создаётся переменная `direction`, которая хранит направление движения в виде двумерного вектора `(Vector2)`.

`Vector2.ZERO` – это `(0, 0)`, то есть объект изначально не движется.

4. `func _physics_process(delta: float) -> void:`
Функция `_physics_process(delta)` выполняется каждый кадр, но с учётом физического времени, чтобы движение было плавным, даже если FPS меняется.
`delta` – время, прошедшее с прошлого кадра (например, 0.016 секунд при 60 FPS).
`-> void` означает, что функция ничего не возвращает.

5. `var direction: Vector2 = Vector2.RIGHT.rotated(rotation)`
`Vector2.RIGHT` – это (1, 0), то есть вектор, направленный вправо.
`.rotated(rotation)` – поворачивает этот вектор на угол `rotation` объекта. <br>
Что это даёт?
Это позволяет объекту двигаться в направлении его поворота. Например:<br>
- Если `rotation = 0`, `direction` остаётся `(1, 0)` (движение вправо).
- Если `rotation = 90°` (или `PI/2` в радианах), вектор `direction` будет `(0, 1)` (вниз).

6. `position += direction * SPEED * delta`
`direction * SPEED` – получает вектор скорости, умножая направление на скорость (`Vector2` * число умножает оба компонента `X` и `Y`).
`* delta` – делает движение зависимым от времени, чтобы объект перемещался равномерно независимо от `FPS`.
`position += ...` – перемещает объект на рассчитанное расстояние.

Что делает этот код?<br>
Объект движется в направлении своего поворота (`rotation`) с постоянной скоростью 800 px/с.
Движение не зависит от `FPS`, потому что используется `delta`.





>[!IMPORTANT]
> Градусы при которых пушка будут зеркалиться зависит от размера пушки (спрайта)

```gdscript
func _physics_process(delta):
	var mouse_pos = get_global_mouse_position() # переменная куда сохраняется глобальная позиция мыши
	look_at(mouse_pos) # метод который поворачивает текущий узел в сторону указанного объекта
	if global_rotation_degrees > 90 or global_rotation_degrees < -90: # условие при котором если глобальные градусы поворота спрайта превышают 90 или меньше -90
		self.flip_v = true # если условие выше является истиной, то спрайт зеркалится
	else: # иначе
		self.flip_v = false # не зеркалится
```

Теперь начнем делать выстрел, однако чтобы наша пушка могла стрелять нам нужны патроны. Для этого создадим новую сцену нашего патрона

Для создания патронов потребуются следующие узлы:

* RigidBody2D
* MeshInstance2D
* CollisionShape2D
* PointLight2D

![image](https://github.com/Sindikaty/byteschool/assets/158248099/2d1e7409-b03b-4b57-b917-ec805dec6a88)

Также можно добавить элемент VisibleOnScreenNotifier2D который позволять нам удалять те пули которые находят за экраном нашей игры
![image](https://github.com/Sindikaty/byteschool/assets/158248099/e2017057-33cd-45af-b1b7-d529715ed1e4)

Для этого у него присоединим узел screen_exited()

![image](https://github.com/Sindikaty/byteschool/assets/158248099/0945adb7-2c9a-4299-a913-9642f380af02)

И в скрипте пропишем
```gdscript
func _on_visible_on_screen_notifier_2d_screen_exited():
	queue_free()
```
А также добавим удаление патронов при касании с какими-либо физическими объектами
Для этого добавим у `RigidBody2D` переменную 
```gdscript
var motion = Vector2()
```
И пропишем следующий скрипт
```gdscript
func _physics_process(delta):
	var collide = move_and_collide(motion * delta)
	if collide:
		queue_free()
```
Теперь вернемся к нашей пушке и в ее коде создадим новую функцию которая будет отвечать за выстрел. 
Для нее нам понадобится 3 переменных 
```gdscript
var can_fire = true # проверка на возможность стрельбы
var bullet = preload("res://bullet.tscn") # подгрузка сцены с пулей
var bullet_speed = 1000 # скорость пули
```
И сама функция стрельбы
```gdscript
func shoot():
	if can_fire: # если игрок может стрелять
		var bullet_instance = bullet.instantiate() # инстанцируется пуля (создается экземпляр указанной сцены, клон проще говоря)
		$bullet_point.position = Vector2(23, -8) # позиция Marker2D (точка вылета пули) мы ставим в позицию которая находится примерно около рук персонажа
		bullet_instance.global_position = $bullet_point.global_position # глобальная позиция инстанцированной пули и точки вылета пули совпадают
		bullet_instance.apply_impulse(Vector2(bullet_speed, 0).rotated(get_parent().rotation), Vector2()) # задаем импульс для инстацнированной пули со скоростью пули и методом указываем направление родительского узла, а вторым вектором - ничего
		get_parent().get_parent().add_child(bullet_instance) # получаем родительский узел дважды и добавляем в сцену нового ребенка, который является инстанцированной пулей
		$sound_gun.play() # проигрывание звука пули
		can_fire = false # запрещаем стрелять игроку
		await get_tree().create_timer(0.5).timeout # Генератор таймера, который истечет за указанное время в скобках (проще говоря это у нас скорострельность пушки)
		can_fire = true # разрешаем пальбу
```
Все что нам осталось это добавить кнопку которая будет отвечать за стрельбу и прописать условия на ее нажатие
```gdscript
func _physics_process(delta):
...
	if Input.is_action_pressed("fire"):
		shoot()
```
### Создание тряски камеры

И последним что мы сделаем на этом уроке, это сделаем тряску камеры при стрельбе. Для нее нам понадобится глобальный скрипт.

Для его создания в меню скриптов нужно нажать `Файл` -> `Новый скрипт` и создать скрипт с названием global или каким-то подобным, после чего зайти в настройки проекта и добавить его в атозагрузку

![image](https://github.com/Sindikaty/byteschool/assets/158248099/69ce34c0-0918-4481-b92d-c2ed9d0ea30d)

```gdscript
var camera = null
```

Для создания тряски прикрепим скрипт к камеры, а также добавим ей `Timer`

![image](https://github.com/Sindikaty/byteschool/assets/158248099/9ad5bb03-c538-425d-875a-193f715db403)

Создадим 3 переменные которые нам понадобсятся для создания тряски экрана
```gdscript
var shake_amount : float = 0
@onready var timer : Timer = $Timer
@onready var tween : Tween = create_tween()
```

Устанавливаем процесс обновления, устанавливаем Global.camera в текущий узел и вызываем функцию randomize().

```gdscript
func _ready():
	set_process(true)
	Global.camera = self
	randomize()
```
Теперь генерируем случайное смещение для создания эффекта тряски.

```gdscript
func _process(_delta: float):
	offset = Vector2(randf_range(-3, 3) * shake_amount, randf_range(-3, 3) * shake_amount)
```
Теперь создадим функцию shake, которая запускает тряску камеры на заданное время с заданным количеством тряски.
```gdscript
func shake(time: float, amount: float):
	timer.wait_time = time
	shake_amount = amount
	set_process(true)
	timer.start()
```
Теперь присоединим узел `_on_timer_timeout()` таймеру. В нем мы останавливаем процесс обновления и запускаем анимацию плавного возвращения камеры в исходное положение.
```gdscript
func _on_timer_timeout() -> void:
	set_process(false)
	tween.interpolate_value(self, "offset", 1, 1, Tween.TRANS_LINEAR, Tween.EASE_IN)
```

Теперь все что нам осталось добавить вызов функции в функцию `shoot()` у оружия

```gdscript
Global.camera.shake(0.2, 1)
```
