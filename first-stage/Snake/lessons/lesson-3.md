# Урок 3 

## Краткое содержание 

- Проверка съедания яблочка
- Проверка окончания игры
- Рост змейки
- Ограничение перемещения на краях карты

## Съедание яблока
Сделаем проверку съедания яблока.
<br>
Условие, при котором змейка съедает яблоко: совпадение координат головы змейки и яблока.<br>
Создадим функцию `check_apple_eaten()`, между функций `move()` и `_on_Timer_timeout()`.<br>
С помощью оператора `if` делаем проверку<br>
При съедении яблока позиция яблока должна поменяться на новую, используем функцию `new_apple()`

### Код:

```gdscript
func check_apple_eaten():
	if apple_pos == snake_body[0]:
		new_apple()
```

Если запустить программу, то яблоки не съедаются. Т.к. мы не вызываем функцию `check_apple_eaten()`, а вызывать её надо при каждом обновлении игры. Допишем в функцию `_on_Timer_timeout()` вызов. <br> Желательное размещение между функциями `move()` и `tile_clear()`, другое размещение вызывает задержку на один такт (яблоко получит новую координату на следующий ход). <br>

### Код:

```gdscript
func _on_timer_timeout():
	move()
	check_apple_eaten()
	tile_clear()
	snake()
```

## Проверка окончания игры

Создадим функцию `check_game_over()`, между функций `check_apple_eaten()` и `_on_Timer_timeout()`.
Для проверки необходимо проверять выход за пределы карты головы змейки. Выделим голову в новую локальную переменную `head`. 

### Код:

```gdscript
func check_game_over():
	var head = snake_body[0] # голова равна первому элементу массива
```
Мы создаем переменную `head`, которая получает значение первого элемента из массива `snake_body`. Это означает, что head представляет собой "голову" змейки в игре. Обычно в играх змейка состоит из нескольких частей, и первая часть — это её голова.


При проигрыше игра будет перезапускаться заново, проверка проигрыша будет вызывать функцию `set_game_over()`, если проверка прошла успешно.

```gdscript
func set_game_over(): 
	get_tree().reload_current_scene() 
```

Давайте теперь дополнять функцию `check_game_over()`:

```gdscript
func check_game_over():
  var head = snake_body[0]
  if head.x > field_size.x: # проверяем, вышла ли голова змейки за правую границу игрового поля. 
    set_game_over() # завершаем игру
  if head.y > field_size.y: # аналогично, здесь мы проверяем, вышла ли голова змейки за верхнюю границу игрового поля
    set_game_over() # завершаем игру
  if head.x < 0 or head.y < 0: # проверяем, не вышла ли голова змейки за левую или нижнюю границу игрового поля
    set_game_over() # завершаем игру
```

>[!Tip]
>При записи дух условий через оператор `or` условие считается истинным, если хотя-бы одно из условий истина.

При проверке ничего не работает, потому что функция `check_game_over()` нигде не вызывается. Добавим её вызов в функцию `_on_Timer_timeout()` в любое место после функции `move()`. <br>
Код:

```gdscript
func _on_timer_timeout():
	move()
	check_game_over()
	check_apple_eaten()
	tile_clear()
	snake()
```

При проверке, если змейка выходит за пределы экрана, то игра перезапускается.

#### Поедание змейки самой себя

Реализуем механику поедания змейки самой себя. Для этого понадобится оператор `for`, чтобы можно было пробежаться по всем элементам массива `snake_body` (тело змейки, напомним).

Полный скрипт:

```gdscript
func check_game_over():
	var head = snake_body[0]
	if head.x > field_size.x:
		set_game_over()
	if head.y > field_size.y:
		set_game_over()
	if head.x < 0 or head.y < 0:
		set_game_over()
	
	for num_block in range(1, snake_body.size() - 1): # вот это добавляем
		if snake_body[num_block] == head:
			set_game_over()
```

А теперь подробнее разберем этот скрипт.

```gdscript
for num_block in range(1, snake_body.size() - 1):
```
Здесь мы используем цикл `for`, чтобы пройти по всем частям тела змейки, начиная со второго элемента (индекс 1) и заканчивая предпоследним элементом (`snake_body.size() - 1`). 

```gdscript
if snake_body[num_block] == head:
    set_game_over()

```
- Внутри цикла мы проверяем, совпадает ли текущий сегмент тела змейки (`snake_body[num_block]`) с головой (`head`).
- Если они совпадают, это означает, что голова столкнулась с каким-либо сегментом тела (что является проигрышным условием в игре "Змейка").
- В этом случае мы вызываем функцию `set_game_over()`, чтобы завершить игру.

И вот таким несложным скриптом мы сделали игру более интересной и сложной.
