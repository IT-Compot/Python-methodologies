# Урок 3 

## Краткое содержание 

- Проверка съедания яблочка
- Проверка окончания игры
- Рост змейки
- Ограничение перемещения на краях карты

## Съедание яблока
Сделаем проверку съедания яблока.
<br>
Условие, при котором змейка съедает яблоко: совпадение координат головы змейки и яблока.<br>
Создадим функцию `check_apple_eaten()`, между функций `move()` и `_on_Timer_timeout()`.<br>
С помощью оператора `if` делаем проверку<br>
При съедении яблока позиция яблока должна поменяться на новую, используем функцию `new_apple()`

### Код:

```gdscript
func check_apple_eaten():
	if apple_pos == snake_body[0]:
		new_apple()
```

Если запустить программу, то яблоки не съедаются. Т.к. мы не вызываем функцию `check_apple_eaten()`, а вызывать её надо при каждом обновлении игры. Допишем в функцию `_on_Timer_timeout()` вызов. <br> Желательное размещение между функциями `move()` и `tile_clear()`, другое размещение вызывает задержку на один такт (яблоко получит новую координату на следующий ход). <br>

### Код:

```gdscript
func _on_timer_timeout():
	move()
	check_apple_eaten()
	tile_clear()
	snake()
```

## Проверка окончания игры

Создадим функцию `check_game_over()`, между функций `check_apple_eaten()` и `_on_Timer_timeout()`.
Для проверки необходимо проверять выход за пределы карты головы змейки. Выделим голову в новую локальную переменную `head`. 

### Код:

```gdscript
func check_game_over():
	var head = snake_body[0] # голова равна первому элементу массива
```
Мы создаем переменную `head`, которая получает значение первого элемента из массива `snake_body`. Это означает, что head представляет собой "голову" змейки в игре. Обычно в играх змейка состоит из нескольких частей, и первая часть — это её голова.


При проигрыше игра будет перезапускаться заново, проверка проигрыша будет вызывать функцию `set_game_over()`, если проверка прошла успешно.

```gdscript
func set_game_over(): 
	get_tree().reload_current_scene() 
```

Давайте теперь дополнять функцию `check_game_over()`:

```gdscript
func check_game_over():
  var head = snake_body[0]
  if head.x > field_size.x: # проверяем, вышла ли голова змейки за правую границу игрового поля. 
    set_game_over() # завершаем игру
  if head.y > field_size.y: # аналогично, здесь мы проверяем, вышла ли голова змейки за верхнюю границу игрового поля
    set_game_over() # завершаем игру
  if head.x < 0 or head.y < 0: # проверяем, не вышла ли голова змейки за левую или нижнюю границу игрового поля
    set_game_over() # завершаем игру
```

>[!Tip]
>При записи дух условий через оператор `or` условие считается истинным, если хотя-бы одно из условий истина.

При проверке ничего не работает, потому что функция `check_game_over()` нигде не вызывается. Добавим её вызов в функцию `_on_Timer_timeout()` в любое место после функции `move()`. <br>
Код:

```gdscript
func _on_timer_timeout():
	move()
	check_game_over()
	check_apple_eaten()
	tile_clear()
	snake()
```

При проверке, если змейка выходит за пределы экрана, то игра перезапускается.

#### Поедание змейки самой себя

Реализуем механику поедания змейки самой себя. Для этого понадобится оператор `for`, чтобы можно было пробежаться по всем элементам массива `snake_body` (тело змейки, напомним).

Полный скрипт:

```gdscript
func check_game_over():
	var head = snake_body[0]
	if head.x > field_size.x:
		set_game_over()
	if head.y > field_size.y:
		set_game_over()
	if head.x < 0 or head.y < 0:
		set_game_over()
	
	for num_block in range(1, snake_body.size() - 1): # вот это добавляем
		if snake_body[num_block] == head:
			set_game_over()
```

А теперь подробнее разберем этот скрипт.

```gdscript
for num_block in range(1, snake_body.size() - 1):
```
Здесь мы используем цикл `for`, чтобы пройти по всем частям тела змейки, начиная со второго элемента (индекс 1) и заканчивая предпоследним элементом (`snake_body.size() - 1`). 

```gdscript
if snake_body[num_block] == head:
    set_game_over()

```
- Внутри цикла мы проверяем, совпадает ли текущий сегмент тела змейки (`snake_body[num_block]`) с головой (`head`).
- Если они совпадают, это означает, что голова столкнулась с каким-либо сегментом тела (что является проигрышным условием в игре "Змейка").
- В этом случае мы вызываем функцию `set_game_over()`, чтобы завершить игру.

И вот таким несложным скриптом мы сделали игру более интересной и сложной.

## Рост змейки
Увеличение длины змейки, если съел яблоко
Добавим глобальную переменную `add_apple`, которая отвечает, за то что съели яблоко, изначально яблоко не съедено, поэтому `false`.

```gdscript
var snake_direction = Vector2(1, 0)
var add_apple = false # добавляем переменную
```
>[!Tip]
>В программировании такую логическую переменную обычно называют «флаг» - если  в одном месте программы она изменяется, а в совершенно другой части программы проверяется её статус и в соответствии с ним производятся действия

Найдём место, где узнаём о съедании яблока. Это функция `check_apple_eaten()`. 
Допишем изменение переменной `add_apple` на `true`, если съели яблоко

```gdscript
func check_apple_eaten():
	if apple_pos == snake_body[0]:
		new_apple()
		add_apple = true # переключаем "флаг"
		print("check apple")
```

И "модерзнириуем" функцию `move()`

```gdscript
func move():
    # Если яблоко не было добавлено (не было съедено)
    if !add_apple:
        # Получаем индекс последнего сегмента тела змейки
        var last_num = snake_body.size() - 1
        # Удаляем последний сегмент тела змейки
        snake_body.remove_at(last_num)
    else:
        # Если яблоко было съедено, сбрасываем флаг добавления яблока
        add_apple = false

    # Вычисляем новую позицию головы змейки
    var new_head = snake_body[0] + snake_direction
    # Вставляем новую голову в начало массива тела змейки
    snake_body.insert(0, new_head)

```

Давайте подробно разберем новый код функции `move()`, который отвечает за движение змейки в игре.

Проверка на добавление яблока

```gdscript
if !add_apple:
    var last_num = snake_body.size() - 1
    snake_body.remove_at(last_num)
else:
    add_apple = false
```

- Здесь мы проверяем, было ли добавлено яблоко (`add_apple`).
- `!add_apple` означает "если не добавлено яблоко". Если яблоко не было добавлено, это значит, что змейка должна сократиться, так как она не съела новое яблоко.
- `var last_num = snake_body.size() - 1` — мы сохраняем индекс последнего сегмента тела змейки. 
- `snake_body.remove_at(last_num)` — удаляем последний сегмент тела змейки. Это делается для того, чтобы сохранить длину змейки постоянной, если она не съела яблоко.
- Если яблоко было добавлено (то есть змейка его съела), то `add_apple` устанавливается в `false`, чтобы в следующем движении снова проверить, было ли съедено новое яблоко.

Вычисление новой головы
```gdscript
var new_head = snake_body[0] + snake_direction
```

- `snake_body[0]` — это текущая позиция головы змейки (первый элемент списка `snake_body`).
- `snake_direction` — это вектор, указывающий направление, в котором движется змейка (например, вправо, влево, вверх или вниз).
- Мы складываем текущую позицию головы и направление движения, чтобы получить новую позицию головы (`new_head`).

Обновление тела змейки

```gdscript
snake_body.insert(0, new_head)
```
- Здесь мы вставляем новую голову (`new_head`) в начало списка `snake_body`. Это означает, что голова змейки теперь находится на новой позиции.
- Метод `insert(0, new_head)` добавляет новый элемент в начало массива, сдвигая все остальные элементы на одну позицию вниз.

Таким образом, функция `move()` отвечает за логику движения змейки. Она проверяет, была ли съедена еда (яблоко), обновляет положение головы и управляет длиной тела змейки в зависимости от того, была ли еда съедена или нет.
