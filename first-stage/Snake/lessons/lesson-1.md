# Урок 1 

## Краткое содержание 
- Создание базовых узлов
- Отрисовка карты, змейки и яблока через код


# Создание базовых узлов

Создаем необходимые базовые узлы:
- `Node2D` - `Game` (корневой узел)
- `Node2D` - `TileMapLayers` (родительский узел для `TileMapLayer`)
- `TileMapLayer` - `Background` (узел с картой)
- `TileMapLayer` - `SnakeApple` (узел с яблоками и змейкой) 

![image](https://github.com/user-attachments/assets/0d55655c-cd0e-432c-b300-57fc6625019e)

Желательно переименовать все узлы для лучшего взаимодействия с ними.

>[!Tip]
>Не забудьте сохранить сцену!

Теперь нужно создать `TileSet` у `Background` и выставить значения свойства `TileSize`:
- `x`: 80
- `y`: 80

После этого добавляем спрайт фона для карты в `TileSet`
![image](https://github.com/user-attachments/assets/e7eb82b1-936a-408d-be8b-daaa236ecaad)

И рисуем карту, чуть перекрывающую viewport
![image](https://github.com/user-attachments/assets/11acdc46-bc28-401f-9688-9fdbd3709569)

Давайте теперь настроим `SnakeApple`
Значения свойства `TileSize` следующие:
- `x`: 40
- `y`: 40

И добавляем спрайты
![image](https://github.com/user-attachments/assets/f50440ce-cc5c-4568-9cd2-ba6b0b3d99ad)

>[!Warning]
>Помните: лучше всего добавить сперва яблоко, а потом уже змейку. Таким образом избежите возможных ошибок в коде, но будет лучше, если вы объясните ученикам, что у первого добавленного элемента будет `id` равен 0, что может повлиять на дальнейший скрипт. 

## Скрипт

Прикрепляем скрипт к корневому узлу `Game`.
И в скрипте мы зададим размеры окна и в будущем будем программировать тут интерфейс.

```gdscript
var field_size = Vector2(29,17) # размеры поля


func _ready():
	var window_size = Vector2((field_size.x + 1) * 40, (field_size.y + 1) * 40) # создаем переменную с размерами окна
	DisplayServer.window_set_size(window_size) # выставляем размеры окна со значением из переменной
```

Разбор по шагам:
- `var field_size = Vector2(29,18)` - здесь создается переменная `field_size`, которая хранит размер игрового поля в виде вектора (ширина и высота). В данном случае поле имеет ширину 29 единиц и высоту 18 единиц.
- `func _ready():` - это функция, которая вызывается при инициализации объекта. Она автоматически запускается при старте сцены.
- `var window_size = Vector2((field_size.x + 1) * 40, (field_size.y + 1) * 40)` - создается новая переменная `window_size` для хранения размера окна. Размер окна рассчитывается следующим образом:
- Ширина окна: `(field_size.x + 1) * 40`. К ширине поля добавляется единица, чтобы учесть границы между клетками, а затем результат умножается на 40 пикселей (предположительно это размер одной клетки).
- Высота окна: `(field_size.y + 1) * 40`. Аналогично, к высоте поля добавляется единица, а затем результат умножается на 40 пикселей.

- `DisplayServer.window_set_size(window_size)` - с помощью функции `window_set_size()` устанавливается размер окна игры согласно рассчитанным значениям ширины и высоты, которые хранятся в переменной `window_size`.

### Добавляем яблоко
Теперь добавим скрипт к `SnakeApple`. Основная часть кода будет написана в этом скрипте.
Нам необходимо где-то хранить позицию нашего яблока, добавим для этого глобальную переменную `apple_pos` типа `Vector2`.

```gdscript
var apple_pos = Vector2() # храним с типом Vector2
```

Создадим функцию генерации яблока, назовем ее `new_apple()` и для генерации случайной последовательности используем функцию `randomize()`.

```gdscript
func _ready():
	pass

func new_apple():
	randomize()
```

>[!Tip]
>Расскажите о работе функции `randomize()`, расскажите про два основных типа "случайности".
>Кратко: существует два типа: псевдослучайный и настоящая случайность. Настоящий рандом возможен, но его получение требует использования специальных устройств или сервисов. В большинстве случаев программисты довольствуются псевдослучайностью, так как она проще в реализации и достаточно хороша для большинства задач.

<details>
<summary>Подробнее про "случайность"</summary>
	
- `Псевдослучайные числа`- большинство языков программирования предоставляют генераторы псевдослучайных чисел. Эти числа генерируются алгоритмами, которые создают последовательность чисел, кажущихся случайными, но на самом деле они детерминированы. То есть если вы запустите программу дважды с одним и тем же начальным состоянием генератора (например, с одинаковым `seed'ом`), то получите одну и ту же последовательность чисел.

```python
import random

random.seed(42)  # Устанавливаем фиксированное семя для воспроизводимости
print(random.randint(0, 100))  # Генерируем целое число от 0 до 100
```

`Настоящие случайные числа`- настоящая случайность может быть получена только из внешних источников, таких как физические процессы, например, радиоактивный распад, шумовой сигнал или даже движение мыши пользователя. Такие источники обеспечивают непредсказуемую последовательность чисел, которую невозможно воспроизвести.

Для получения настоящих случайных чисел используются специальные аппаратные устройства или внешние сервисы, такие как:

- Аппаратные генераторы случайных чисел (HWRNG), встроенные в некоторые процессоры или отдельные устройства.
- Онлайн-сервисы, предоставляющие настоящие случайные данные, такие как Random.org.
</details>

И далее пишем следующий скрипт:

```gdscript
func new_apple():
	randomize() # функция для рандомизации сида
	var x = int(randi_range(0, field_size.x + 1)) # локальная переменная со случайным значением от 0 до размера игрового поля 
	var y = int(randi_range(0, field_size.y + 1)) #
	apple_pos = Vector2(x, y) # Соберем сгенерированные координаты x и y в вектор apple_pos
	print("x: ", x) # распечатаем x
	print("y: ", y) # распечатаем y
```

>[!Warning]
> Обращаем внимание, что полученные значения должны быть целыми, т.к. это позиция яблока, и в последующем мы будем её сравнивать с позицией головы. А нам известно, что 10 ≠ 10,1

Если кто-то из детей уже написал и успел сразу же запустить игру, то может столкнуться с тем, что ничего не видно. Но почему? Потому что функция `new_apple()` не вызывается. Вызовем её из функции `_ready()`, дописав в конец функции строчку `new_apple()`

```gdscript
func _ready():
	new_apple() # вызываем нашу функцию


func new_apple():
	randomize()
	var x = int(randi_range(0, field_size.x + 1))
	var y = int(randi_range(0, field_size.y + 1))
	apple_pos = Vector2(x, y)
	draw_apple(x, y)
	print("x: ", x)
	print("y: ", y)
```

Теперь позиция генерируется, но само яблоко еще не видно. Исправим это.

```gdscript
func draw_apple(x, y): # создаем еще ниже новую функцию с параметрами функции
	set_cell(Vector2i(apple_pos.x, apple_pos.y), 0, Vector2(), 0) # применяем функцию set_cell для отрисовки
```

Если же снова кто-то успел написать и запустил игру - столкнется с отсутствием яблока. Почему? Функция просто не вызывается => не работает. Нужно её вызвать внутри другой функции, например, из функции `new_apple()`.

```gdscript
func new_apple():
	randomize()
	var x = int(randi_range(0, field_size.x + 1))
	var y = int(randi_range(0, field_size.y + 1))
	apple_pos = Vector2(x, y)
	draw_apple(x, y) # вызываем нашу функцию и указываем в аргументе данные
	print("x: ", x)
	print("y: ", y)

func draw_apple(x, y):
	set_cell(Vector2i(apple_pos.x, apple_pos.y), 0, Vector2(), 0)
```

Теперь яблоко видно, отлично!

#### Сделаем отрисовку змеи

Змейка – это последовательность клеток, в которой она находится, начиная от головы и заканчивая хвостом. Каждый элемент змейки занимает ровно одну клетку (в `TM_SnakeApple`), поэтому для описания одной клетки нам нужна переменная типа `Veсtor2`. Змейка состоит не из одного тайла, а из нескольких, поэтому нам понадобится массив, в котором по очереди будут сохраняться все элементы змейки.
Назовём массив элементов змейки `snake_body`, этот массив будет глобальной переменной, объявим его следом за `apple_pos`. Зададим массиву начальные значения – стартовую змейку из трёх элементов с координатами `(4,7), (3,7), (2,7)`.
Добавляем новую переменную

```gdscript
var snake_body = [Vector2(4, 7), Vector2(3, 7), Vector2(2, 7)]

```

Теперь надо так же отрисовать змею, как мы отрисовали яблоко.

```gdscript
func draw_snake():
	for block in snake_body: # отрисуем циклом
		set_cell(block, 3, Vector2(), 0) # рисуем змейку по итерации цикла
```

При проверке змейка и яблоко должны отобразиться на экране.
