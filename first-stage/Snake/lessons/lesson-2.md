# Урок 2 

## Краткое содержание 

- Код стирания старой змейки
- Перерисовка змейки для её движения
- Управление клавишами

## Затирание змейки

Сделать затирания всех игровых тайлов (для яблока и змейки)
Игра будет покадровая, каждый кадр мы будем отрисовывать функцией `draw()`, но старый кадр нам нужно удалять (очищать).
Назовем новую функцию `clear()` (очистка). 
Получим список координат используемых клеток в `SnakeApple` с помощью функции `get_used_cells_by_id()` и сохраним этот список в локальную переменную `cell_list`.

### Скрипт
```gdscript
func tile_clear():
	var cell_list = $".".get_used_cells_by_id(3) # добавляем в скобочки id тайла змейки
	for cell in cell_list:
		$".".set_cell(cell, -1, Vector2(), -1) # стираем клетки итерационно
```

Для каждой клетки нам нужно стереть тайл по отдельности. Для повторяющихся многократно действий используем цикл `for` по массиву. А для затирания клетки внутри цикла используем уже известную функцию `set_cell()`, с указанием типа нового таила равного минус 1

## Движение змейки

Как заставить змейку двигаться? Движение будет реализовано следующим образом: у нас будет таймер, который будет перерисовывать сетку тайлмэпа и таким образом перемещать змейку.

Движение состоит из двух частей: 
- подтянуть хвост (удалить последний тайл)
- добавить новый таил по направлению движения

Направление движения это новая глобальная переменная типа `Vector2` назовем её `snake_direction` и зададим начальные значения `(1, 0)`, что соответствует движению вправо (Объявим переменную после объявления `snake_body`)

```gdscript
var snake_direction = Vector2(1, 0) # направление движения
```

Создадим новую функцию - движения, назовем её `move()` 
Удалим последнюю ячейку массива. Используя функцию `remove_at()`, данная функция требует указания номера удаляемого элемента, в нашем случае это последний элемент. Вычислим последний элемент с помощью функции `size()`, возвращающей количество элементов массива, но количество элементов не равно номеру последнего элемента, т.к. нумерация начинается с 0. Поэтому номер последнего элемента будет на единицу меньше, чем количество, сохраним этот номер в локальной переменной `last_num`. 

Далее дополним змейку новой головой. Используя функцию `insert()`, данная функция требует указания в какое место массива вставляется элемент (его номер) и самого нового элемента. Номер будет 0, т.к. это должен быть первый элемент. А новый элемент нужно вычислить, для этого возьмем текущее положение головы змейки (элемент массива `snake_body` под номером 0) и добавим к нему вектор перемещения `snake_direction`). Новый элемент сохраним в локальной переменной `new_head`.

### Скрипт
```gdscript
func move():
  var last_num = snake_body.size() - 1 # добавляем последний элемент тела змейки
  snake_body.remove_at(last_num) # убираем его 
  var new_head = snake_body[0] + snake_direction # создаем новую голову с учетом направления
  snake_body.insert(0, new_head) # добавляем "новую" голову
```

## Таймер
![image](https://github.com/user-attachments/assets/3a2e5476-c9de-4d84-9001-1d9f35783937)

Движение змейки должно проходить постоянно, с определённым интервалом, в этом нам поможет узел `Timer`, добавляем его к узлу `Game` и можно переименовать в `Timer`, а можем не переименовывать.
Настраиваем таймер в `Инспектор`
- Свойство `Wait Time` ― время срабатывания таймера, будет равно задержке между передвижением на одну клетку, установим примерно `0,2` (время задаётся в секундах).
- Свойство `Autostart` ― отвечает за автоматическое включение таймера при старте. Ставим галочку (включаем).

### Скрипт

Присоединим сигнал от узла `Timer` к нашему скрипту.
Перейти на вкладку `Узел` рядом с вкладкой `Инспектор`.
Найти сигнал истечения времени (`timeout()`) и присоединить его к узлу со скриптом. В скрипте автоматически создается функция `_on_Timer_timeout()`. 

Прописываем в функцию `_on_Timer_timeout()` вызовы функций `move()`, `tile_clear()` и `draw_snake()`. Т.е. сначала рассчитываем ход, потом очищаем и следом перерисовываем. Строчка `pass` нам не нужна.

```gdscript
func _on_timer_timeout():
	move() # движение
	tile_clear() # очистка тайлов
	draw_snake() # отрисовка змейки
```

## Управление змеей 

Добавим управление.
Добавим в конец скрипта новую встроенную функцию `_input(event)` (отвечает за обработку клавиш), она выполняется при нажатии любой клавиши или передвижении курсора в окне игры.
Сделаем обработку нажатой клавиши (именно нажатия, а не удержания), например будем использовать клавиши со стрелками. Получаем проверку сделанную оператором `if`, условие входящее событие `Input` и примененная функция `is_action_just_pressed()` с обработкой каждой из четырёх кнопок: `ui_up`, `ui_right`, `ui_left`, `ui_down`.
При выполнении условия (нажатия клавиши) будем менять направление движения, которое хроним в переменной `snake_direction`. Для направления вверх зададим `Vector2(0,-1)`. 
Для изменения направления движения вверх. Код:

```gdscript
func _input(event):
	if Input.is_action_just_pressed("ui_up"):
		snake_direction = Vector2(0, -1)

```

При проверке змейка начинает реагировать на клавишу.
Дописываем код для остальных клавиш. Код:

```gdscript
func _input(event):
	if Input.is_action_just_pressed("ui_up"):
		snake_direction = Vector2(0, -1)
	if Input.is_action_just_pressed("ui_down"):
		snake_direction = Vector2(0, 1)
	if Input.is_action_just_pressed("ui_right"):
		snake_direction = Vector2(1, 0)
	if Input.is_action_just_pressed("ui_left"):
		snake_direction = Vector2(-1, 0)
```

При проверке змейка начинает реагировать на все клавиши.
Если заметили ошибку, что змея может начать двигаться в обратном направлении от текущего направления движения и есть время на уроке, то можешь открыть раздел по кнопке ниже и ознакомиться с решением.
<details>
	<summary>Расширенное управление</summary>
	
```gdscript
func _input(event):
	if Input.is_action_just_pressed("ui_up"):
		if not snake_direction == Vector2(0, 1):
			snake_direction = Vector2(0, -1)
	if Input.is_action_just_pressed("ui_down"):
		if not snake_direction == Vector2(0, -1):
			snake_direction = Vector2(0, 1)
	if Input.is_action_just_pressed("ui_right"):
		if not snake_direction == Vector2(-1, 0):
			snake_direction = Vector2(1, 0)
	if Input.is_action_just_pressed("ui_left"):
		if not snake_direction == Vector2(1, 0):
			snake_direction = Vector2(-1, 0)
```
 
</details>

# Итоги
